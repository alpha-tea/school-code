 Общие рекомендации для решения задач, книга - Златопольский Д.М. Сборник задач по программированию, 3-е задание. 

Глава 1. Ввод и вывод числовых данных. Опертор присваивания.


 Простейшие программы. Арифметические выражения.

 В этом разделе скорее важно попробовать запустить среду разработки, настроить проект и скомпилировать код. Попробовать первые запуски программ.

 1.1-1.13 - четные или нечетные на выбор, если есть варианты, то варианты все.
 1.14-1.17 - в каждом задании выбрать 3-4 варианта поразнообразней, использовать функции математической,и блиотеки math.h можно посмотреть в справочнике.
 1.18-21 - четные или нечетные на выбор, достаточно одного варианта в каждом задании.

 Вычисления по известным формулам.

 Здесь много типовых заданий, которые попадются на разного рода практических, контрольных и прочих лабораторных. 

 1.22-23 - один вариант или оба по вкусу.
 1.25-29 - полностью, не сложные, но часто встречающиеся.
 1.30 - один вариант на выбор.
 1.31 - очень популярная, оба варианта.
 1.35-37 - придеться немного вспомнить геометрию.
 1.39-42 - любую одну на выбор но все параметры.
 1.44-1.51 - четные или нечетные на выбор.
 1.52-1.54 - одну на выбор, арифметика.
 1.55-56 - одну на выбор, задача на движение.
 1.57-58 - обязательно(58-ая часть её), т.к. будет в КиР.

 Часто используемые алгоритмы.

 1.59-1.60 - обе, т.к. типовой алгоритм обмена переменными.
 1.61-1.62 - 2-3 на выбор из каждой.


Глава 2. Целочисленная арифметика.


 Простейшие задачи: 2.1-2.4 - одну на выбор; 2.6 - полностью на время; 2.8-2.9 - одну на выбор.

 Выделение цифр в записи числа: 2.12-18 - обязательно, для вычислений и закрепления последовательности действий, можно оформить как одно задание и объединить; 2.21-23 - одну по желанию дополнительно(или можно пропустить).

 Нахождение целого числа по информации о его цифрах: 2.24-2.33 - три-пять на выбор, число Н другие параметры вводить с клавиатуры не надо, просто задать его как переменную. Оставить подробнее комментарии как именно было решено, т.к. задания могут показаться немного запутанными.

 Задачи повышенной сложности. 2.34-36 - любая полностью; 2.37-38 - одна на выбор. 2.39-42 - запутанно, но одну на выбор, если получится дополнительно посмотреть. 2.43 - попытаться применить хитрость. :). Все задачи повышенной сложности либо делать подробнее вывод в консоль, что происходит, либо снабжать текст комментариями. В задачах на последовательности активно применять целочисленную арифметику.


Глава 3. Величины логического типа.

 В этой главе для классического Си удобно использовать переменную целочисленного типа и определять значения истины как 1, ложь - как 0. Вывод подробнее в консоль. В других языках программирования можно использовать специальный логический тип по стандарту.

 Вычисление логических выражения. 

 3.1-3.10 - четные или нечетные по выбору, все варианты.
 3.11-3.12 - одну на выбор, любые 2-3 варианта.
 3.13-3.26 - любую каждую третью(14,17,20,23...), все варианты в выбранных.

 Составление логических выражений.

 3.27-3.31 - две на выбор, все варианты.
 3.32-3.33 - одну на выбор, подробнее вывод в консоль(можно просто ссылку на рисунок).
 3.34-3.35 - дополнительно, не обязательно, но 3-4 варианта из каждой реализовать, они небольшие. Заглянуть в Вики, чтобы уточнить правила шахмат. Также можно уже начать набрасывать общую модель для игры в шахматы, после будем её дополнять.


Глава 4. Условные оператор.


 Полный условный оператор: 4.1-2 - одну на выбор; 4.5 - оба варианта; 4.6-12 - три любые на выбор; 4.13-14 - обязательно, т.к. часто попадается; 4.15 - не совсем ясно почему здесь стоит применять условный оператор, но на вещании мы её сделали; 4.16-17 - одну на выбор, оба варианта; задачи помеченные звездой оставляем на десерт, если всё быстро пойдет, то их сделаем по завершению главы.

 Целочисленная арифметика и условный оператор: хм, эту часть мы решали во второй главе очень активно, можно пропустить. Но если трубуется закрепление, то можно каждую 3-ую задачу реализовать, по желанию. 4.20-36. 4.35 - можно попробовать.

 Использование сложных условий: 4.37 - по желанию, после если что закомментировать ввод; 4.39 попробовать переменные, чтобы попасть во все области; 4.40-41 - одна на выбор; 4.42-48 - 3 любые на выбор; 4.49 - обязательно, распространенное задание; 4.50-52 - одна на выбор; 4.53 - полностью; 4.55-60 - одна на выбор, оба варианта; 4.61 - обязательно, часто встречаемая; 4.62-64 - одну на выбор; 4.65 - обязательно, пригодиться в работе, календарь часто сложнее чем кажется; 4.66-69 - чуть сложнее, дополнительно, или оставить на десерт.

 Неполный и вложенные условные операторы: 4.70-75 - три четные или нечетных номера, переменные можно использовать по ходу одни и те же или с дополнениями, оба варианта реализовать; 4.76-77 - одну по желанию, т.к. есть ввод, после решения можно закомментировать; 4.78-80 - все, но не использовать цикл и объединить решение как одну, использовать один массив целочисленных; 4.81-84 - аналогичны предыдущим, можно пропустить; 4.85-90 - четные или нечетные на выбор, можно оформлять сложными логическими выражениями; 4.91-93 - одну на выбор, предпочтительней 91-ая, все варианты(а-в); 4.94-103 - четные или нечетные на выбор, цикл не использовать.

 Оператор выбора варианта(switch): 4.110 - полностью; 4.111 - дополнительно по желанию, пример с календарем.

 Задачи повышенной сложности: 4.116-4.141 - свободное решение дополнительно, от 5 до 25 задач по возможности. Задачи выбранные и фактически решенные на вещании: 4.125; 4.128; 4.132; 4.134-135; 4.140-4.141. Задачи решенные мною по ходу планирования: 4.118, 4.119, 4.125, 4.128, 4.132, 4.134, 4.135, 4.140.


Глава 5. Оператор цикла с параметром.


 Организация вывода данных по требуемому формату: 5.3 - полностью все варианты, обьединить всё в одну большую таблицу, параметры А и Б просто задать и размер таблицы ограничить на 5-7 строк в итоге(можно использовать табуляции или пробелы и формат через поля принтф); 5.8-5.10 - все, и так же можно обьединить в один цикл и одну большую таблицу построить(шапку таблицы не забыть), но можно и по отдельности; 5.11-5.12 - любая на выбор; 5.15 - можно просто в строчку вывод сделать, без клавиатуры; 5.16-5.26 - четные или нечетные по выбору, также можно объединять в одну таблицу, если удобно.

 Обработка фиксированной последовательности чисел: 5.27-5.30 - одну на выбор, но все варианты, значения задавать переменной; 5.31-5.35 - сделать все, но попробовать использовать один цикл по Н и можно условные операторы, вывести суммы уже после цикла, если не получается, то через циклы на каждую задачу, причем если Н меньше чем по условию, то можно сделать последовательность чуть короче, но минимум 3 элемента должно быть в каждой из них. Результаты по элементам и сумме удобней представить в типе double.

 Обработка данный во время ввода: 5.39-5.56 - каждую 3-ую задачу, использовать генератор случайных чисел для всех задач в этом разделе; 5.57-5.65 - каждую 3-ую тоже. Если где-то не указано количество элементов, то минимум использовать 3-7 элементов.

 Рекуррентные соотношения: это полезный раздел как на практике, так и потом пригодится нам для изучения. 5.66-5.76 - все задачи по возможности, но если есть варианты, то можно ограничиться только одним в задании. Все задания разворачивать последовательность через пробел в консоль. Индексы можно записывать в виде A[k], A[n+1] и т.д. Дроби представлять ввиде целочисленной пары числителя и знаменателя.

 Расчет площади кривой: простые численные методы, одна по желанию, но так-то существуют более общие алгоритмы.

 Разные задачи: 5.81-5.85 все подряд; 5.86-5.96 - четные или нечетные на выбор; в этом разделе постараться оформить вычисления ввиде отдельных функций.

 Общие рекомендации: использовать для последовательностей заданных с клавиатуры(или просто случанайных цифр) значений генератор случайных чисел.

printf("Example of random sequence, #include <stdlib.h>: ");
srand(0);   // Инициализация последовательности случайных чисел любым другим значением.
for (int i = 0; i < 10; ++i) {
    int a = rand() % 100;   // Генерируем числа от 0 до 99.
    printf("%d ", a);
}
printf("\n");


 Глава 6. Операторы цикла с условием.


 Обработка числовых последовательностей. 6.1-6.21 - каждую третью на выбор, для последовательностей использовать или генератор случайных чисел или простые правила. В последовательностях удобней применять ограничения достаточные для тестирования алгоритма, не слишком длинные, но и не короткие.

 Использование условного оператора в теле операторов цикла с условием. 6-22-6.42. Каждую третью по выбору. Слишком длинные последовательности желательно не выводить или выводить в строку, через любой разделитель, "запятая" или "пробел". 6.43-44. Задачи объединить в один цикл и сделать все вычисления рядом. Использовать можно простые целые числа, вместо вещественных и простой генератор через сложение, чтобы получалась последовательность не возрастающих чисел. Также можно посчитать частоту вхождения чисел в последовательность. Использовать при этом пару целочисленных массивов для удобства. 6.45. - классика, реализовать на основе описания алгоритма и оформить в отдельную функцию с тестированием нескольких вариантов.
 
 Использование условного оператора после операторов цикла с условием. 6.46-6.75 - каждую третью на выбор, все варианты, если их несколько. Там где ограничения по числу слишком велики или последовательность слишком длинная, то по использовать минимальные параметры для проверки. 6.52 - можно простым перебором в цикле, классические алгоритмы оставим на десерт. 6.76-6.79 - оформить ввиде функций, которые возвращают integer - позицию искомого элемента последовательности или -1, если элемент не найден. Параметры прогрессий вводить ввиде переменных на вход функции; для 6.76 - можно сделать одну универсальную функцию, а не две разных.

 Использование условного оператора в теле операторов цикла с условием и после него. 6.80-6.87 - каждую вторую на выбор.

 Разные задачи. 6.88-6.90 - одну на выбор; 6.91 - полностью, оформить ввиде функции; 6.92-93 - одну на выбор, можно использовать целочисленные массивы или простую последовательность; 6.94-95 - одну на выбор; 6.96-6.97 - по желанию одну на выбор, использовать массивы, в последующих главах где будет поиск/массивы будут аналогичные; 6.98-6.101 - уже делали в предыдущих главах, так что по желанию или пропускаем; 6.102-6.103 - классика, обязательно, оформить функцией с подробным выводом в консоль и передачей параметров по адресу; 6.104-6.105 - одну на выбор; 6.106-6.111 - все, можно обьединять некоторые задачи; 6.112-6.114 - часть уже делали, так что любые по желанию или можно пропустить; 6.115 - попробовть один вариант, может пригодиться дальше.


 Глава 7. Сочетание оператора цикла и условного оператора.


 Во всей главе не вводить данные вручную с клавиатуры, а использовать генерацию данных похитрее.

 Простейшие задачи: 7.1-7.12 - любые четные или нечетные по выбору; 7.13 - полностью все варианты, разложение на делители сделать более подробно;

 Организация вычислений во время ввода данных: 7.14-7.17 - все примерно одинаковые, четные или нечетные по выбору, можно в одном цикле оформить; 7.18-7.20 - одну на выбор; 7.21-24 - одну на выбор; 7.25-32 - частично мы уже далали подобные, поэтому 2 любые, через 4, на выбор; 7.33-37 - все задания объединить в одно, использовать только целые числа(не вещественные), последовательность генерировать на лету или в массив по вкусу; 7.38 - не совсем ясно в чем именно задача, но может еще посмотрим; 7.39 - мы уже делали пожожую, но тогда пришлось разбирать на вещании, попробуй сделать самостоятельно, это часто распространенная задача относительно физики; 7.40-42 - одну на выбор, простая; 7.43-7.46 четные или нечетные на выбор; 7.47-48 - аналогичные, только с более реальными примерами, по желанию одну для наглядности или можно пропустить; 7.49-51 - одну на выбор, применить генератор похитрее, если получиться, т.е. ввести счетчик или флаг, при обработке которого нужные числа будут сгенерированы(можно через увеличивающийся шанс).

 Определение максимального и минимального значений во время вввода данных: 7.52-7.57 - каждую третью, на выбор, использовать генерацию последовательностей; 7.58-7.59 - одну на выбор с выводом исходных данных и результатов вычислений; 7.60-7.63 - одну на выбор, можно с массивами или просто последовательностями; 7.64-7.66 - одну на выбор; 7.67-7.72 - каждую третью на выбор; 7.73-7.76 - одну на выбор, все варианты, в один цикл; 7.77 - не понятно, что именно требуется может обсудим; 7.78-7.79 - одну на выбор; 7.80-7.83 - все полностью, можно применять массивы или без них(82 и 83 можно обьединить); 7.84-85 - уже частично делали ранее, только если будет желание.

 Использование условного оператора после оператора цикла: 7.86-7.89 - объединить все вопросы в одну задачу, последовательность целочисленная; 7.90-7.93 - одну на выбор; 7.94-7.95 - тоже одну на выбор.

 Использование условного оператора в теле оператора цикла с условием и после него: 7.96-7.100 - одну на выбор, или можно объединить пару для разнообразия; 7.101-7.102 - одну на выбор, аналогично, но одним циклом; 7.103-7.108 - каждую третью на выбор; 7.109-7.110 - либо теоретически ответить, либо одну на выбор с демонстрацией; 7.111-7.116 - каждую третью на выбор; 7.117-7.118 - одну на выбор(обьединить с предыдущими); 7.119-7.123 - одну на выбор, часть уже была; 7.124-7.125 - обьединить задания, но они и так частично совпадают; 7.126-7.127 - оформить вспомогательные функции для каждой задачи, это дополнительные задания, если что разберем их вместе часть уже была; 7.128 - обязательно, т.к. она часто встречается.

Даниил и все. Дополнительное задание от ScriptedEngineer. Даны целые числа в произвольном диапазоне(возьмем наверное просто от 0 до 255). Вывести на экран те из них, которые в бинарном(двоичном) виде являются палиндромами, т.е. читаются одинаково слева-направо и наоборот.
Оформим отдельной функцией все это в стиле void scripted_engineer_1(). Отдельно также сдалаем функцию перевода целого unsigned char в строку, т.е. void to_binary(unsigned char byte, char string[]). Использовать будем именно массив char[] или строку, не int, как мы переводили до этого.


 Глава 8. Вложенные циклы.


 В всей главе быть осторожным с составным оператором и оформлением отступов. Там где есть параметры в заданиях, стараться использовать оператор for, там где есть простые условия, то лучше while оператор. Ввод с клавиатуры заменить на генерацию последовательностей.

 Организация вывода с использованием вложенных циклов: 8.1-8.8 - каждую четвертую на выбор, все варианты; 8.9-8.10 - одну на выбор, сделать два вывода алгоритмически.

 Обработка данных во время ввода с использованием вложенных циклов: 8.11-8.22 - каждую 3-ую, все варианты, если таблицы очень большие, то уменьшить количество строк(записей) и уплотнить вывод; 8.23 - полностью, все варианты поподробнее; 8.24 - дополнительно по желанию.

 Вложенные циклы и целые числа: 8.25-8.38 - построить таблицу делителей чисел от 1 до n(можно небольшое), с выводом всех делителей до 1 и их общее количество. Вывести общее количество чисел, количество делителей которых равно k, можно отметить их по ходу вывода таблицы столбцом или уже после таблицы по вкусу. Найти числа, которые имеют максимальное и минимальное количество делителей. Вывести сумму делителей и отметить те из них, которые кратны m, а также числа с минимальной и максимальной суммой делителей. Отметить те числа в таблице, которые являются простыми и совершенными, можно использовать наши предыдущие функции. Определить пары всех дружественных чисел, суммы делителей которых равны между собой; 8.39-8.40 - одну на выбор; 8.41 - можно немного снизить поиск параметра решений с 30 до 10; 8.42-42 - одну на выбор, можно применять битовые операторы; 8.44-45 - одна на выбор, через циклы, без арифметики; 8.46 - пропускаем, уже делали.

 Дополнительные задания повышенной сложности. 8.50 - похожая задача, но можно применить сдвиги по номиналу монет, вывода сделать по нескольким n и подробно, сколько купюр и какого достоинства используются, посчитать контрольную сумму, подумать над доказательством минимальной комбинации. 8.51 - интересная задача, можно даже будет позже оформить в отдельную функцию и дополнительно рискнуть применить рекурсию. От произвольного числа до одной цифры, через последовательное вычисления. Описать все этапы в консоли. 8.53-8.54 - только второй вариант, либо записать в формате "множитель:количество", используем нашу функцию простоты числа, объединить в одно задание; 8.55-8.57 - относительно простая, применить поиск НОД по Евклиду и ввести параметр p, а не n для поиска взаимной простоты; 8.56 - не совсем ясно условие, так что пропускаем или еще подумаем; 8.58 - не совсем понятно что именно подразумевается под "способами", но если в протом виде, найти просто кубы слагаемых, может еще подумаем; 8.59 - вот как раз на рациональные числа, задать дроби и поискать среди них, шаг числителя и знаменателя 1, и возможно лучше будет задать ограничитель произвольный, не только 7.


 Глава 9. Строки символов.


 В этой главе стоит реализовывать все необходимые функции самостоятельно, стараясь не использовать встроенные библиотечные функции. Можно дополнить функции дополнительными проверками на допустимость параметров. Для Си это классический массив char, для остальных языков можно выбирать по вкусу. Также пробежаться по теоретическим вопросам в начале главы. В книге Праты, главы 4 и 11 прочитать и/или повторить.

 Простейшие задачи. 9.1-9.5 - одну на выбор, можно сначала сделать с вводом с клавиатуры, а потом закомментировать и подставить для ускорения вывода простую переменную; 9.6 и 9.11 - можно обьединить или реализовать только одну; 9.7-9.10 и 9.12 - обьединить все задания в одну; даны 3 строки(можно названия городов или любые), и выполнить действия из всех задач для этих 3-ех строк, желательно часть оформить ввиде кратких функций - вычисление длины строки и обмен содержимым двух строк, если потребуется; int string_length(char s[]) и void string_exchange(char s1[], char s2[]).

 Работа с символами строки. 9.13-9.21 - каждую 3-ую задачу на выбор, индексацию символов удобней вести с 0; 9.22-9.23 - одну на выбор; 9.24-9.30 - обьединить в одну, взять 3 слова на английском и получить вырезкой и вставкой других 1-3 слова на английском, слова подобрать покороче и использовать простые методы без автоматического поиска, просто подставив буквы, реализовать дополнительно функцию - копирование подстроки из строки int string_copy_substr(char src[], char dst[], int start, int length); 9.31-9.36 - взять также 3-5 строк и произвольные слова, получить 1-3 иных английских слов путем замены букв, пары "поиск-замена" можно занести в массив или в ручную, реализовать дополнительно функцию поиска индекса буквы в строке int string_find_char(char src[], char c); 9.37-9.40 - реализовать универсальную одну функцию, которая делит строку на равные части, а потом меняет их местами в строке, простым перемешиванием или иным способом, можно дополнить еще способом прямого, обратного или чет/нечет и т.д. Порядок символов в частях сохранить, работать внутри исходной строки. Дополнительно для сложности можно использовать только один символ для обмена.

 Обработка строк с использованием оператора цикла с параметром. 

 Эту часть мы случайно проскочили мимо, но если что тут стоит поработать без использования функций, которые мы реализовали уже в следующей части. Простые циклы и работа с индексами символов.

9.41-9.42 - дана строка, вывести её столбиком и в обратном порядке.
9.43 - дана строка, вывести четный или нечетный порядок следования символов на выбор. 
9.47 и 9.49 - дана строка, добавить к слову символ A, количество N, задать параметры по выбору.
9.50 - как есть, параметрами сделать позицию старта и длину замены символов, не забыть проверить на допустимость.
9.51-9.65 - дана строка, вывести: заданные символы из второй строки и все их позиции, символы уникальны, количество различных символов можно задать параметром или искать все, до конца строки; посчитать общее количество каждого найденного символа и  долю от обшего поиска (N/M) всех найденных символов; вывести каждый N символ в строке; также посчитать количество последовательностей соседних равных символов и их индексы, задать количество соседних; исходную строку можно взять подлинее.
9.66-9.74 - дана строка текста, словом называется последовательность символов между символами разделителями. Символы разеделители пока что: пробел, новая строка и табуляция. Посчитать количество слов и дополнительно попробовать отформатировать заданный текст, ограничив длину строки в N символов и реализовав перенос по словам, пробелы, табуляции, переносы строк оставить в потоке символов и если слово длинней ширины, то печатать просто по символам как есть без переноса. Если ширина поля менее одного размера табуляции, то просто оставить пустую строку. // только с этой строкой.

 Обработка строк с использованием операторов цикла с условием.

 В этом разделе мы немного изменяем задания и разрабатываем универсальные функции для работы со строками.

9.75-9.77 - написать функцию поиска символа в строке. На входе строка, символ, направление поиска(с начала или конца) и флаг вывода символов во время поиска на экран. На выходе индекс первого найденного символа или -1, если символ не найден. int string_char_find(char s[], char c, int direct, int debug), протестировать функцию в разнообразных вариациях входных данных; 9.78 - уже кажется делали, но только для числа, если не делали для строки, то сделать функцию на проверку строки на палиндром; 9.79 - написать функцию подсчета количества заданного символа в строке. На входе строка и символ, на выходе - количество символов или нуль, если символов не найдено(вроде мы уже делали такое, так что можно просто вызвать/скопировать/модифицировать) int string_char_counter(char s[], char c); 9.80 - написать функцию определения последовательности одинаковых букв в строке с определенного символа и заданной длиной, на входе строка, символ, стартовый индекс и длина последовательности; на выходе 1 - есть совпадение, 0 - нету совпадения по всей требуемой длине; int string_find_seq(char s[], char c, int start, int length). 9.81 - модифицировать нашу функцию определения равнозначности строк, если строки равны, то вернуть 0, если больше 0, то это вернуть количество первых символов, которые совпадают в строках, но не полностью и -1, если не один из символов не совпал(чуть подкорректировать предыдущую задачу). 9.82-9.84 - часть тестирования предыдущих функций, поэтому пропускаем(пара символов это последовательность из 2 одинаковых); 9.86-9.87 - написать функцию поиска подстроки в строке, пока что простой вариант, int string_find_sub(char s1[], char s2[]), -1 - если не найдена строка полностью; 0 или более - индекс найденной подстроки в строке. И функцию замены всех подстрок в строке на другую подстроку или сделать рычаг управления. На вход исходная строка, подстрока для поиска, подстрока для замены и флаг замены всех или только первого попавшегося. На выход: количество фактических замен. int string_replace_sub(char src[], char find[], char replace[], int all); - протестировать на паре примеров. 9.88-9.89 - реализовать используя комбинации предыдущих функций и проверить.

 Изменение исходных строковых величин

 В этом разделе все операции должны производиться внутри исходной строки, дополнительные строки желательно не использовать, или максимум временно, но вернуть в итоге измененную исходную строку. Использовать по возможности функции, которые были разработаны в предыдущем разделе.

9.90-9.91 - дана исходная строка и строка содержащая символы пар поиск-замены, char [] = { 'a', 'b', 'e', 'f'} и тд или в обычную строку(четные-нечетные) всё вместе. Используя функцию поиска символа в строке string_char_find(...), осуществить замену всех символов заданных в парах.
9.92-9.93 - дана исходная строка и строка вида char[] c парами типа "'символ', интервал", char[] = { 'a', 2, 'b', 5}. Не используя дополнительных функций, заменить все K-символы интервала в исходной строке на символ в таблице.
9.94-9.99 - дана исходная строка, и массив слов вида char* words[]. Применяя функцию поиска подстроки в строке, заменить искомое слово на второе слово в паре, массива words[], при этом известно что длина слов в паре одинкова.
9.100-9.102 - дана исходная строка и массив пар индексов int[], поменять местами символы в строке, по соотвествующим парам индексов, оформить ввиде функции string_xchg_chars(char src[], int table[], int count), где count - количество пар, которые необходимо поменять. Тестирование функции в следующих заданиях.
9.103-107 - используя функцию из предыдущего задания реализовать генератор последовательностей замены символов в исходной строке, по таблицам. В таблицы в ручную не задавать. Строку взять хотя бы из 15 символов по минимуму. 103 - заменить символы в парах 1-2, 3-4, ... n-(n+1). 104 - перевернуть строку в обратном порядке таблицей, 1-n, 2-(n-1), ... (n/2)-(n/2). 105-106 - одной тоже прямо тексту, задать параметры. 107 - использовать предыдущую функцию поиска символа в строке.
9.108-9.112 - реализовать функцию удаления символов из строки, не забыть проверить всё на допустимость и правильно обрезать по новому размеру, на выход отправить код ошибки. int string_delete(char src[], int start, int length);
9.114 - классическая задача, реализовать полностью, исходная строка подлинее и генерируется случайным образом. Можно даже вывести количество итераций, которое потребовалось условно алгоритму на сравнения/замены и какие именно по индексам символы были удалены.
9.115-9.117 - пропускаем, уже реализовали функцию удаления символов и проверку строки на палиндром делали главами ранее.
9.118-9.123 - дана исходная строка c минимум тремя словами и словарь из отдельных слов char* words[]. Реализовать функцию вставки подстроки в строку, со смещением оставшихся символов, не перезаписывая исходную строку и скоректировав размер. Вернуть код ошибки. int string_insert(char dst[], char ins[], int start).
9.124-9.137 - дана строка состоящая из слов с условными ошибками, разделенные только пробелами. Взять 3-5 слов хотя бы. И дан словарь char* dict[], с правильным написанием тех же слов. Выделить слова из первой строки, определить совпадение(количество равных букв), и если количество совпадений по буквам более чем параметр доли N, то заменить это слово на словарное, длина слов должна совпадать.
9.124-9.137 - написать две функции циклического сдвига символов в строке, void string_rlc(src[], int counter); void string_rrc(src[], int counter). На вход: строка исходник и количество сдвигов. Символ, который выходит за пределы строки, пенеоситься в последнюю или первую позицию строки.

 Обработка цифр в строке

 Здесь первые задания можно сделать без применения функций, т.к. они краткие. Но последующие уже можно с функциями.

9.138-9.141 - полностью, обьединить все задания в одну, не применять функции. Вывести: является ли символ цифрой, вывести эту цифру, вычислить количество цифр, сумму этих цифр и максимальную среди них.
9.142-9.144 - реализовать функцию преобразования строки в число, основания системы счисления использовать от 2 до 16. Если вместе с цифрами попадаются буквы, то их пропустить. Если ни одной цифры не попалось, то просто вернуть нуль. int string_to_int(src[], int base). Протестировать на нескольких примерах и на системах счисления с основаниями 2,8,10,16.
9.145-9.147 - одна задача на выбор, можно чуть более подробнее вывод.

 Задачи повышенной сложности

 В этом разделе активно использовать предыдущие функции.

9.152-9.153 - дана строка предложение, найти наибольшее количество идущих подряд одинаковых символов.
9.154-9.155 - исходная строка содержит текст, определить какие уникальные буквы в нем есть, и сколько их в строке.
9.156-9.159 - дано два слова, строки 1 и 2, в одно задание. Определить какие буквы первого слова входят во второе слово, какие буквы второго слова входят в первое и их количество, повторояющиеся буквы не учитывать. Определить буквы, которые есть только в одном из них. Определить буквы, которые встречаются в обоих словах только один раз.
9.160 - так же, два слова в паре строк. Оба варианта реализовать. Строгое и не строгое совпадение.
9.161-9.163 - задания аналогичны предыдущим, если требуется еще практика, то можно и их тоже решать.




Дополнительные задания, для подготовки к олимпиаде.

 ну и всем желающим тоже. Пробегаюсь пока по заданиям, достаточно распространены и могут попасться задачи на системы счисления. Так что пока для разогрева тебе типовое, но и повторишь заодно как мы тогда раскладывали числа. :)
 

 Даны несколько результатов вывода чисел в неизвестных системах счисления от 2 до N, определить основания этих систем счисления, если известно, что используется минимально возможное представление этих чисел и вывести их в десятичной системе счисления. Удобней использовать для входных данных, текстовое представление с цифрами и если понадобиться с буквами. Вывод по алгоритму желательно реализовать подробнее. Варианты:

1: 123, 2: 796, 3: 60452, 4: 101001, 5: 32674, 6: 306973, 7: 2F4B, 8: 1C2AB

Универсальная функция перевода из любой системы счисления в любую другую. int num_radix(char src[], char dst[], int from, int to); Из текстового предтсавления. :)
 Ограничение от 2 до 16. На выход можно подать длину условно цифры, сколько цифр в итоге получилось или -1, если была ошибка. :)


