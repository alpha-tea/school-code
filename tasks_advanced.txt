 Общие рекомендации для решения задач, книга - Златопольский Д.М. Сборник задач по программированию, 3-е задание. 

Глава 1. Ввод и вывод числовых данных. Опертор присваивания.


 Простейшие программы. Арифметические выражения.

 В этом разделе скорее важно попробовать запустить среду разработки, настроить проект и скомпилировать код. Попробовать первые запуски программ.

 1.1-1.13 - четные или нечетные на выбор, если есть варианты, то варианты все.
 1.14-1.17 - в каждом задании выбрать 3-4 варианта поразнообразней, использовать функции математической,и блиотеки math.h можно посмотреть в справочнике.
 1.18-21 - четные или нечетные на выбор, достаточно одного варианта в каждом задании.

 Вычисления по известным формулам.

 Здесь много типовых заданий, которые попадются на разного рода практических, контрольных и прочих лабораторных. 

 1.22-23 - один вариант или оба по вкусу.
 1.25-29 - полностью, не сложные, но часто встречающиеся.
 1.30 - один вариант на выбор.
 1.31 - очень популярная, оба варианта.
 1.35-37 - придеться немного вспомнить геометрию.
 1.39-42 - любую одну на выбор но все параметры.
 1.44-1.51 - четные или нечетные на выбор.
 1.52-1.54 - одну на выбор, арифметика.
 1.55-56 - одну на выбор, задача на движение.
 1.57-58 - обязательно(58-ая часть её), т.к. будет в КиР.

 Часто используемые алгоритмы.

 1.59-1.60 - обе, т.к. типовой алгоритм обмена переменными.
 1.61-1.62 - 2-3 на выбор из каждой.


Глава 2. Целочисленная арифметика.


 Простейшие задачи: 2.1-2.4 - одну на выбор; 2.6 - полностью на время; 2.8-2.9 - одну на выбор.

 Выделение цифр в записи числа: 2.12-18 - обязательно, для вычислений и закрепления последовательности действий, можно оформить как одно задание и объединить; 2.21-23 - одну по желанию дополнительно(или можно пропустить).

 Нахождение целого числа по информации о его цифрах: 2.24-2.33 - три-пять на выбор, число Н другие параметры вводить с клавиатуры не надо, просто задать его как переменную. Оставить подробнее комментарии как именно было решено, т.к. задания могут показаться немного запутанными.

 Задачи повышенной сложности. 2.34-36 - любая полностью; 2.37-38 - одна на выбор. 2.39-42 - запутанно, но одну на выбор, если получится дополнительно посмотреть. 2.43 - попытаться применить хитрость. :). Все задачи повышенной сложности либо делать подробнее вывод в консоль, что происходит, либо снабжать текст комментариями. В задачах на последовательности активно применять целочисленную арифметику.


Глава 3. Величины логического типа.

 В этой главе для классического Си удобно использовать переменную целочисленного типа и определять значения истины как 1, ложь - как 0. Вывод подробнее в консоль. В других языках программирования можно использовать специальный логический тип по стандарту.

 Вычисление логических выражения. 

 3.1-3.10 - четные или нечетные по выбору, все варианты.
 3.11-3.12 - одну на выбор, любые 2-3 варианта.
 3.13-3.26 - любую каждую третью(14,17,20,23...), все варианты в выбранных.

 Составление логических выражений.

 3.27 - минимум три любые варианта на выбор.
 3.28-3.31 - четные или нечетные по выбору, все варианты.
 3.32-3.33 - одну на выбор, подробнее вывод в консоль(можно просто ссылку на рисунок).
 3.34-3.35 - по 3-4 варианта разнообразней из каждой реализовать, они небольшие. Заглянуть в Вики, чтобы уточнить правила шахмат. Также можно уже начать набрасывать общую модель для игры в шахматы, после будем её дополнять.

 Не хватает в репозитории. 3.1-3.10. чет/нечет. 11-12 - есть; 3.13-3.26 - просто переставить по порядку и еще одну для комплекта реализовать. 3.28 или 3.29 - любую полностью, с выводом вычислений.


Глава 4. Условные оператор.


 Условный оператор и его различные формы. Там где возможно использовать полную форму оператора вместо нескольких. Если слишком длинные условные выражения, то либо разбить их на несколько строк или несколько операторов, главное чтобы было понятно и читабельно для нас.

 Полный условный оператор.

 4.1-4.2 - одну на выбор;
 4.5 - оба варианта;
 4.6-4.12 - три любые по выбору;
 4.13-4.14 - обязательно, обе полностью, т.к. часто попадается;
 4.15 - не совсем ясно почему здесь стоит применять условный оператор, но на вещании мы её сделали, по желанию;
 4.16-4.17 - одну на выбор, оба варианта;
 4.18-4.19 - одну на выбор, по желанию или если требуется потренироваться на олимпиаду.

 Целочисленная арифметика и условный оператор.

 Хм, эту часть мы решали во второй главе очень активно, но для закрепления желательно реализовать, т.к. будут как раз комбинации целочисленной арифметки и условных операторов.

 4.20-4.22 и 4.34 - объединить в одно задание вывести все результаты анализа числа сразу;
 4.23-4.26 - одно задание на выбор, но все варианты;
 4.27-4.31 - также одно задание на выбор, аналогичное преыдущему;
 4.32-4.33 - их уже желательно реализовать с помощью циклов, так что лучше их пропустить, или по желанию;
 4.35-4.36 - классика, постараться сделать обе.

 Использование сложных условий.

 4.37 - после проверки если что закомментировать ввод, чтобы каждый раз не вводить при тестировании;
 4.39 - попробовать значения переменных, чтобы попасть во все области на рисунке и протестировать все ветки;
 4.40-4.41 - одна на выбор, использовать вещественные переменные;
 4.42-4.45 - все, но использовать одни и те же переменные(можно разные значения) и постараться реализовать более сложные компактные условия;
 4.46-4.47 - одну на выбор, немного вспомнить формулы;
 4.48 - аналогична, пропускаем;
 4.49 - обязательно, распространенное задание на разного рода лабораторных;
 4.50-4.53 - нечетные номера, быть внимательным с парметрами;
 4.55-4.60 - одна на выбор, оба варианта, уже делали много похожих в предыдущей главе;
 4.61 - обязательно, часто встречаемая;
 4.62-4.64 - одну на выбор, цифры выделенные можно сохранить в отдельные переменные;
 4.65 - обязательно, пригодиться в работе, календарь часто сложнее чем кажется;
 4.66-4.69 - чуть сложнее, дополнительно, хотя бы попытаться решить.

 Неполный и вложенные условные операторы.

 4.70-4.71 - одну на выбор, выполнить все варианты, с подробным выводом по какой именно ветки условия мы прошли;
 4.72-4.73 - дополнительно, для заркепления, можно пропустить;
 4.74-4.75 - одну по выбору, не перепутать знаки и использовать вещественные переменные;
 4.76-4.78 - обьединить в одну сразу по всем трем параметрам, не использовать ввод с клавиатуры;
 4.79-4.80 - также объединить решение как одну, все варианты;
 4.81-4.84 - аналогичны предыдущим, можно пропустить;
 4.85-4.90 - четные или нечетные на выбор, можно оформлять более сложными логическими выражениями по желанию;
 4.91-4.93 - одну на выбор, предпочтительней 91-ая, все варианты(а-в); 
 4.94-4.103 - четные или нечетные на выбор, цикл не использовать, вывод более краткий для закрепления.

 Оператор выбора варианта.

 4.110 - полностью; 
 4.111 - дополнительно по желанию, пример с календарем, т.к. уже это задание было.

 Задачи повышенной сложности.

 Все задания в этом разделе делать по возможности, но желательно разноообразано.
 
 4.116-4.118 - по возможности постараться решить 4.118, если не получается, то одну любую на выбор;
 4.119-4.120 - попробовать 4.120, каждый четвертый вариант со всеми параметрами, если трудно, то 4.119 - все варианты интерпретация "хода" свободная;
 4.121 - дополнительно, можно пропустить;
 4.122-4.124 - попытаться объединить в одну, вспомнить формулы;
 4.125-4.128 - одну на выбор, которая удобней, вывод формы слов можно реализовать транслитерацией;
 4.129-4.131 - аналогичные, только если захочется закрепить материал, в остальном пропустить;
 4.132 - любопытная задача, попробовать решить, помнить про часы и ход времени;
 4.133-4.134 - только 1.134, в следующих главах оформим функцию, запасная задача 4.133;
 4.135 - светофор, классика, полностью;
 4.136 - уже была, если есть желание, то повторить;
 4.137-4.140 - одну на выбор, без строк;
 4.141 - относительно простая; 

 Далее просто списки заданий для первого вещания, требуется обновить по мере продвижения.

 Задачи выбранные и фактически решенные на вещании: 4.125; 4.128; 4.132; 4.134-135; 4.140-4.141. 
 Задачи решенные мною по ходу планирования: 4.118, 4.119, 4.125, 4.128, 4.132, 4.134, 4.135, 4.140.


Глава 5. Оператор цикла с параметром.


 Организация вывода данных по требуемому формату: 5.3 - полностью все варианты, обьединить всё в одну большую таблицу, параметры А и Б просто задать и размер таблицы ограничить на 5-7 строк в итоге(можно использовать табуляции или пробелы и формат через поля принтф); 5.8-5.10 - все, и так же можно обьединить в один цикл и одну большую таблицу построить(шапку таблицы не забыть), но можно и по отдельности; 5.11-5.12 - любая на выбор; 5.15 - можно просто в строчку вывод сделать, без клавиатуры; 5.16-5.26 - четные или нечетные по выбору, также можно объединять в одну таблицу, если удобно.

 Обработка фиксированной последовательности чисел: 5.27-5.30 - одну на выбор, но все варианты, значения задавать переменной; 5.31-5.35 - сделать все, но попробовать использовать один цикл по Н и можно условные операторы, вывести суммы уже после цикла, если не получается, то через циклы на каждую задачу, причем если Н меньше чем по условию, то можно сделать последовательность чуть короче, но минимум 3 элемента должно быть в каждой из них. Результаты по элементам и сумме удобней представить в типе double.

 Обработка данный во время ввода: 5.39-5.56 - каждую 3-ую задачу, использовать генератор случайных чисел для всех задач в этом разделе; 5.57-5.65 - каждую 3-ую тоже. Если где-то не указано количество элементов, то минимум использовать 3-7 элементов.

 Рекуррентные соотношения: это полезный раздел как на практике, так и потом пригодится нам для изучения. 5.66-5.76 - все задачи по возможности, но если есть варианты, то можно ограничиться только одним в задании. Все задания разворачивать последовательность через пробел в консоль. Индексы можно записывать в виде A[k], A[n+1] и т.д. Дроби представлять ввиде целочисленной пары числителя и знаменателя.

 Расчет площади кривой: простые численные методы, одна по желанию, но так-то существуют более общие алгоритмы.

 Разные задачи: 5.81-5.85 все подряд; 5.86-5.96 - четные или нечетные на выбор; в этом разделе постараться оформить вычисления ввиде отдельных функций.

 Общие рекомендации: использовать для последовательностей заданных с клавиатуры(или просто случанайных цифр) значений генератор случайных чисел.

printf("Example of random sequence, #include <stdlib.h>: ");
srand(0);   // Инициализация последовательности случайных чисел любым другим значением.
for (int i = 0; i < 10; ++i) {
    int a = rand() % 100;   // Генерируем числа от 0 до 99.
    printf("%d ", a);
}
printf("\n");


 Глава 6. Операторы цикла с условием.


 Обработка числовых последовательностей. 6.1-6.21 - каждую третью на выбор, для последовательностей использовать или генератор случайных чисел или простые правила. В последовательностях удобней применять ограничения достаточные для тестирования алгоритма, не слишком длинные, но и не короткие.

 Использование условного оператора в теле операторов цикла с условием. 6-22-6.42. Каждую третью по выбору. Слишком длинные последовательности желательно не выводить или выводить в строку, через любой разделитель, "запятая" или "пробел". 6.43-44. Задачи объединить в один цикл и сделать все вычисления рядом. Использовать можно простые целые числа, вместо вещественных и простой генератор через сложение, чтобы получалась последовательность не возрастающих чисел. Также можно посчитать частоту вхождения чисел в последовательность. Использовать при этом пару целочисленных массивов для удобства. 6.45. - классика, реализовать на основе описания алгоритма и оформить в отдельную функцию с тестированием нескольких вариантов.
 
 Использование условного оператора после операторов цикла с условием. 6.46-6.75 - каждую третью на выбор, все варианты, если их несколько. Там где ограничения по числу слишком велики или последовательность слишком длинная, то по использовать минимальные параметры для проверки. 6.52 - можно простым перебором в цикле, классические алгоритмы оставим на десерт. 6.76-6.79 - оформить ввиде функций, которые возвращают integer - позицию искомого элемента последовательности или -1, если элемент не найден. Параметры прогрессий вводить ввиде переменных на вход функции; для 6.76 - можно сделать одну универсальную функцию, а не две разных.

 Использование условного оператора в теле операторов цикла с условием и после него. 6.80-6.87 - каждую вторую на выбор.

 Разные задачи. 6.88-6.90 - одну на выбор; 6.91 - полностью, оформить ввиде функции; 6.92-93 - одну на выбор, можно использовать целочисленные массивы или простую последовательность; 6.94-95 - одну на выбор; 6.96-6.97 - по желанию одну на выбор, использовать массивы, в последующих главах где будет поиск/массивы будут аналогичные; 6.98-6.101 - уже делали в предыдущих главах, так что по желанию или пропускаем; 6.102-6.103 - классика, обязательно, оформить функцией с подробным выводом в консоль и передачей параметров по адресу; 6.104-6.105 - одну на выбор; 6.106-6.111 - все, можно обьединять некоторые задачи; 6.112-6.114 - часть уже делали, так что любые по желанию или можно пропустить; 6.115 - попробовть один вариант, может пригодиться дальше.


 Глава 7. Сочетание оператора цикла и условного оператора.


 Во всей главе не вводить данные вручную с клавиатуры, а использовать генерацию данных похитрее.

 Простейшие задачи: 7.1-7.12 - любые четные или нечетные по выбору; 7.13 - полностью все варианты, разложение на делители сделать более подробно;

 Организация вычислений во время ввода данных: 7.14-7.17 - все примерно одинаковые, четные или нечетные по выбору, можно в одном цикле оформить; 7.18-7.20 - одну на выбор; 7.21-24 - одну на выбор; 7.25-32 - частично мы уже далали подобные, поэтому 2 любые, через 4, на выбор; 7.33-37 - все задания объединить в одно, использовать только целые числа(не вещественные), последовательность генерировать на лету или в массив по вкусу; 7.38 - не совсем ясно в чем именно задача, но может еще посмотрим; 7.39 - мы уже делали пожожую, но тогда пришлось разбирать на вещании, попробуй сделать самостоятельно, это часто распространенная задача относительно физики; 7.40-42 - одну на выбор, простая; 7.43-7.46 четные или нечетные на выбор; 7.47-48 - аналогичные, только с более реальными примерами, по желанию одну для наглядности или можно пропустить; 7.49-51 - одну на выбор, применить генератор похитрее, если получиться, т.е. ввести счетчик или флаг, при обработке которого нужные числа будут сгенерированы(можно через увеличивающийся шанс).

 Определение максимального и минимального значений во время вввода данных: 7.52-7.57 - каждую третью, на выбор, использовать генерацию последовательностей; 7.58-7.59 - одну на выбор с выводом исходных данных и результатов вычислений; 7.60-7.63 - одну на выбор, можно с массивами или просто последовательностями; 7.64-7.66 - одну на выбор; 7.67-7.72 - каждую третью на выбор; 7.73-7.76 - одну на выбор, все варианты, в один цикл; 7.77 - не понятно, что именно требуется может обсудим; 7.78-7.79 - одну на выбор; 7.80-7.83 - все полностью, можно применять массивы или без них(82 и 83 можно обьединить); 7.84-85 - уже частично делали ранее, только если будет желание.

 Использование условного оператора после оператора цикла: 7.86-7.89 - объединить все вопросы в одну задачу, последовательность целочисленная; 7.90-7.93 - одну на выбор; 7.94-7.95 - тоже одну на выбор.

 Использование условного оператора в теле оператора цикла с условием и после него: 7.96-7.100 - одну на выбор, или можно объединить пару для разнообразия; 7.101-7.102 - одну на выбор, аналогично, но одним циклом; 7.103-7.108 - каждую третью на выбор; 7.109-7.110 - либо теоретически ответить, либо одну на выбор с демонстрацией; 7.111-7.116 - каждую третью на выбор; 7.117-7.118 - одну на выбор(обьединить с предыдущими); 7.119-7.123 - одну на выбор, часть уже была; 7.124-7.125 - обьединить задания, но они и так частично совпадают; 7.126-7.127 - оформить вспомогательные функции для каждой задачи, это дополнительные задания, если что разберем их вместе часть уже была; 7.128 - обязательно, т.к. она часто встречается.

Даниил и все. Дополнительное задание от ScriptedEngineer. Даны целые числа в произвольном диапазоне(возьмем наверное просто от 0 до 255). Вывести на экран те из них, которые в бинарном(двоичном) виде являются палиндромами, т.е. читаются одинаково слева-направо и наоборот.
Оформим отдельной функцией все это в стиле void scripted_engineer_1(). Отдельно также сдалаем функцию перевода целого unsigned char в строку, т.е. void to_binary(unsigned char byte, char string[]). Использовать будем именно массив char[] или строку, не int, как мы переводили до этого.


 Глава 8. Вложенные циклы.


 В всей главе быть осторожным с составным оператором и оформлением отступов. Там где есть параметры в заданиях, стараться использовать оператор for, там где есть простые условия, то лучше while оператор. Ввод с клавиатуры заменить на генерацию последовательностей.

 Организация вывода с использованием вложенных циклов: 8.1-8.8 - каждую четвертую на выбор, все варианты; 8.9-8.10 - одну на выбор, сделать два вывода алгоритмически.

 Обработка данных во время ввода с использованием вложенных циклов: 8.11-8.22 - каждую 3-ую, все варианты, если таблицы очень большие, то уменьшить количество строк(записей) и уплотнить вывод; 8.23 - полностью, все варианты поподробнее; 8.24 - дополнительно по желанию.

 Вложенные циклы и целые числа: 8.25-8.38 - построить таблицу делителей чисел от 1 до n(можно небольшое), с выводом всех делителей до 1 и их общее количество. Вывести общее количество чисел, количество делителей которых равно k, можно отметить их по ходу вывода таблицы столбцом или уже после таблицы по вкусу. Найти числа, которые имеют максимальное и минимальное количество делителей. Вывести сумму делителей и отметить те из них, которые кратны m, а также числа с минимальной и максимальной суммой делителей. Отметить те числа в таблице, которые являются простыми и совершенными, можно использовать наши предыдущие функции. Определить пары всех дружественных чисел, суммы делителей которых равны между собой; 8.39-8.40 - одну на выбор; 8.41 - можно немного снизить поиск параметра решений с 30 до 10; 8.42-42 - одну на выбор, можно применять битовые операторы; 8.44-45 - одна на выбор, через циклы, без арифметики; 8.46 - пропускаем, уже делали.

 Дополнительные задания повышенной сложности. 8.50 - похожая задача, но можно применить сдвиги по номиналу монет, вывода сделать по нескольким n и подробно, сколько купюр и какого достоинства используются, посчитать контрольную сумму, подумать над доказательством минимальной комбинации. 8.51 - интересная задача, можно даже будет позже оформить в отдельную функцию и дополнительно рискнуть применить рекурсию. От произвольного числа до одной цифры, через последовательное вычисления. Описать все этапы в консоли. 8.53-8.54 - только второй вариант, либо записать в формате "множитель:количество", используем нашу функцию простоты числа, объединить в одно задание; 8.55-8.57 - относительно простая, применить поиск НОД по Евклиду и ввести параметр p, а не n для поиска взаимной простоты; 8.56 - не совсем ясно условие, так что пропускаем или еще подумаем; 8.58 - не совсем понятно что именно подразумевается под "способами", но если в протом виде, найти просто кубы слагаемых, может еще подумаем; 8.59 - вот как раз на рациональные числа, задать дроби и поискать среди них, шаг числителя и знаменателя 1, и возможно лучше будет задать ограничитель произвольный, не только 7.


 Глава 9. Строки символов.


 В этой главе стоит реализовывать все необходимые функции самостоятельно, стараясь не использовать встроенные библиотечные функции. Можно дополнить функции дополнительными проверками на допустимость параметров. Для Си это классический массив char, для остальных языков можно выбирать по вкусу. Также пробежаться по теоретическим вопросам в начале главы. В книге Праты, главы 4 и 11 прочитать и/или повторить.

 Простейшие задачи. 9.1-9.5 - одну на выбор, можно сначала сделать с вводом с клавиатуры, а потом закомментировать и подставить для ускорения вывода простую переменную; 9.6 и 9.11 - можно обьединить или реализовать только одну; 9.7-9.10 и 9.12 - обьединить все задания в одну; даны 3 строки(можно названия городов или любые), и выполнить действия из всех задач для этих 3-ех строк, желательно часть оформить ввиде кратких функций - вычисление длины строки и обмен содержимым двух строк, если потребуется; int string_length(char s[]) и void string_exchange(char s1[], char s2[]).

 Работа с символами строки. 9.13-9.21 - каждую 3-ую задачу на выбор, индексацию символов удобней вести с 0; 9.22-9.23 - одну на выбор; 9.24-9.30 - обьединить в одну, взять 3 слова на английском и получить вырезкой и вставкой других 1-3 слова на английском, слова подобрать покороче и использовать простые методы без автоматического поиска, просто подставив буквы, реализовать дополнительно функцию - копирование подстроки из строки int string_copy_substr(char src[], char dst[], int start, int length); 9.31-9.36 - взять также 3-5 строк и произвольные слова, получить 1-3 иных английских слов путем замены букв, пары "поиск-замена" можно занести в массив или в ручную, реализовать дополнительно функцию поиска индекса буквы в строке int string_find_char(char src[], char c); 9.37-9.40 - реализовать универсальную одну функцию, которая делит строку на равные части, а потом меняет их местами в строке, простым перемешиванием или иным способом, можно дополнить еще способом прямого, обратного или чет/нечет и т.д. Порядок символов в частях сохранить, работать внутри исходной строки. Дополнительно для сложности можно использовать только один символ для обмена.

 Обработка строк с использованием оператора цикла с параметром. 

 Эту часть мы случайно проскочили мимо, но если что тут стоит поработать без использования функций, которые мы реализовали уже в следующей части. Простые циклы и работа с индексами символов.

9.41-9.42 - дана строка, вывести её столбиком и в обратном порядке.
9.43 - дана строка, вывести четный или нечетный порядок следования символов на выбор. 
9.47 и 9.49 - дана строка, добавить к слову символ A, количество N, задать параметры по выбору.
9.50 - как есть, параметрами сделать позицию старта и длину замены символов, не забыть проверить на допустимость.
9.51-9.65 - дана строка, вывести: заданные символы из второй строки и все их позиции, символы уникальны, количество различных символов можно задать параметром или искать все, до конца строки; посчитать общее количество каждого найденного символа и  долю от обшего поиска (N/M) всех найденных символов; вывести каждый N символ в строке; также посчитать количество последовательностей соседних равных символов и их индексы, задать количество соседних; исходную строку можно взять подлинее.
9.66-9.74 - дана строка текста, словом называется последовательность символов между символами разделителями. Символы разеделители пока что: пробел, новая строка и табуляция. Посчитать количество слов и дополнительно попробовать отформатировать заданный текст, ограничив длину строки в N символов и реализовав перенос по словам, пробелы, табуляции, переносы строк оставить в потоке символов и если слово длинней ширины, то печатать просто по символам как есть без переноса. Если ширина поля менее одного размера табуляции, то просто оставить пустую строку. // только с этой строкой.

 Обработка строк с использованием операторов цикла с условием.

 В этом разделе мы немного изменяем задания и разрабатываем универсальные функции для работы со строками.

9.75-9.77 - написать функцию поиска символа в строке. На входе строка, символ, направление поиска(с начала или конца) и флаг вывода символов во время поиска на экран. На выходе индекс первого найденного символа или -1, если символ не найден. int string_char_find(char s[], char c, int direct, int debug), протестировать функцию в разнообразных вариациях входных данных; 9.78 - уже кажется делали, но только для числа, если не делали для строки, то сделать функцию на проверку строки на палиндром; 9.79 - написать функцию подсчета количества заданного символа в строке. На входе строка и символ, на выходе - количество символов или нуль, если символов не найдено(вроде мы уже делали такое, так что можно просто вызвать/скопировать/модифицировать) int string_char_counter(char s[], char c); 9.80 - написать функцию определения последовательности одинаковых букв в строке с определенного символа и заданной длиной, на входе строка, символ, стартовый индекс и длина последовательности; на выходе 1 - есть совпадение, 0 - нету совпадения по всей требуемой длине; int string_find_seq(char s[], char c, int start, int length). 9.81 - модифицировать нашу функцию определения равнозначности строк, если строки равны, то вернуть 0, если больше 0, то это вернуть количество первых символов, которые совпадают в строках, но не полностью и -1, если не один из символов не совпал(чуть подкорректировать предыдущую задачу). 9.82-9.84 - часть тестирования предыдущих функций, поэтому пропускаем(пара символов это последовательность из 2 одинаковых); 9.86-9.87 - написать функцию поиска подстроки в строке, пока что простой вариант, int string_find_sub(char s1[], char s2[]), -1 - если не найдена строка полностью; 0 или более - индекс найденной подстроки в строке. И функцию замены всех подстрок в строке на другую подстроку или сделать рычаг управления. На вход исходная строка, подстрока для поиска, подстрока для замены и флаг замены всех или только первого попавшегося. На выход: количество фактических замен. int string_replace_sub(char src[], char find[], char replace[], int all); - протестировать на паре примеров. 9.88-9.89 - реализовать используя комбинации предыдущих функций и проверить.

 Изменение исходных строковых величин

 В этом разделе все операции должны производиться внутри исходной строки, дополнительные строки желательно не использовать, или максимум временно, но вернуть в итоге измененную исходную строку. Использовать по возможности функции, которые были разработаны в предыдущем разделе. Хм, стоит подумать над заранее подготовленными данными для проверки.

9.90-9.91 - дана исходная строка и строка содержащая символы пар поиск-замены, char [] = { 'a', 'b', 'e', 'f'} и тд или в обычную строку(четные-нечетные) всё вместе. Используя функцию поиска символа в строке string_char_find(...), осуществить замену всех символов заданных в парах.
9.92-9.93 - дана исходная строка и строка вида char[] c парами типа "'символ', интервал", char[] = { 'a', 2, 'b', 5}. Не используя дополнительных функций, заменить все K-символы интервала в исходной строке на символ в таблице.
9.94-9.99 - дана исходная строка, и массив слов вида char* words[]. Применяя функцию поиска подстроки в строке, заменить искомое слово на второе слово в паре, массива words[], при этом известно что длина слов в паре одинкова.
9.100-9.102 - дана исходная строка и массив пар индексов int[], поменять местами символы в строке, по соотвествующим парам индексов, оформить ввиде функции string_xchg_chars(char src[], int table[], int count), где count - количество пар, которые необходимо поменять. Тестирование функции в следующих заданиях.
9.103-107 - используя функцию из предыдущего задания реализовать генератор последовательностей замены символов в исходной строке, по таблицам. В таблицы в ручную не задавать. Строку взять хотя бы из 15 символов по минимуму. 103 - заменить символы в парах 1-2, 3-4, ... n-(n+1). 104 - перевернуть строку в обратном порядке таблицей, 1-n, 2-(n-1), ... (n/2)-(n/2). 105-106 - одной тоже прямо тексту, задать параметры. 107 - использовать предыдущую функцию поиска символа в строке.
9.108-9.112 - реализовать функцию удаления символов из строки, не забыть проверить всё на допустимость и правильно обрезать по новому размеру, на выход отправить код ошибки. int string_delete(char src[], int start, int length);
9.114 - классическая задача, реализовать полностью, исходная строка подлинее и генерируется случайным образом. Можно даже вывести количество итераций, которое потребовалось условно алгоритму на сравнения/замены и какие именно по индексам символы были удалены.
9.115-9.117 - пропускаем, уже реализовали функцию удаления символов и проверку строки на палиндром делали главами ранее.
9.118-9.123 - дана исходная строка c минимум тремя словами и словарь из отдельных слов char* words[]. Реализовать функцию вставки подстроки в строку, со смещением оставшихся символов, не перезаписывая исходную строку и скоректировав размер. Вернуть код ошибки. int string_insert(char dst[], char ins[], int start).
9.124-9.137 - дана строка состоящая из слов с условными ошибками, разделенные только пробелами. Взять 3-5 слов хотя бы. И дан словарь char* dict[], с правильным написанием тех же слов. Выделить слова из первой строки, определить совпадение(количество равных букв), и если количество совпадений по буквам более чем параметр доли N, то заменить это слово на словарное, длина слов в тексте и словаре должна совпадать. Неверные буквы в исходной строке можно выделить заглавными.
9.124-9.137 - написать две функции циклического сдвига символов в строке, void string_rlc(src[], int counter); void string_rrc(src[], int counter). На вход: строка исходник и количество сдвигов. Символ, который выходит за пределы строки, пенеоситься в последнюю или первую позицию строки.

 Обработка цифр в строке

 Здесь первые задания можно сделать без применения функций, т.к. они краткие. Но последующие уже можно с функциями.

9.138-9.141 - полностью, обьединить все задания в одну, не применять функции. Вывести: является ли символ цифрой, вывести эту цифру, вычислить количество цифр, сумму этих цифр и максимальную среди них.
9.142-9.144 - реализовать функцию преобразования строки в число, основания системы счисления использовать от 2 до 16. Если вместе с цифрами попадаются буквы, то их пропустить. Если ни одной цифры не попалось, то просто вернуть нуль. int string_to_int(src[], int base). Протестировать на нескольких примерах и на системах счисления с основаниями 2,8,10,16. int int_to_string(dst[], int num, int base). Не забыть наличие знака. И пару функций с тернарным оператором в дополнение, char upppercase(char c) и функция void string_reverse(char src[]). Uppercase - должна занимать одну строчку, использовать тернарный оператор.
9.147 - можно чуть более подробнее вывод, в качестве разделителя использовать знак + или -.

 Задачи повышенной сложности

 В этом разделе активно использовать предыдущие функции. 

9.152-9.153 - дана строка предложение, найти наибольшее количество идущих подряд одинаковых символов.
9.154-9.155 - исходная строка содержит текст, определить какие уникальные буквы в нем есть, и сколько их в строке.
9.156-9.159 - дано два слова, строки 1 и 2, в одно задание. Определить какие буквы первого слова входят во второе слово, какие буквы второго слова входят в первое и их количество, повторояющиеся буквы не учитывать. Определить буквы, которые есть только в одном из них. Определить буквы, которые встречаются в обоих словах.
9.160 - так же, два слова в паре строк. Оба варианта реализовать. Строгое и не строгое совпадение. Минимальный набор для тестирования удобней организовать парами слов. Среди них пара в которой не совпадает ни один символ, где есть не строгое и строгое соответствие по поиску. Пример: "char* word_pairs[] = { "blue", "cyan", "magenta", "tag", "red", "deer" };".
9.161-9.163 - задания аналогичны предыдущим, если требуется еще практика, то можно и их тоже решать.
9.164 - это достаточно большое задание, если от него стартовать. Поэтому возьмем его с учетом объединения с последующими. Далее по тексту. Дана строка предложение, которая состоит из слов. Слова это всё так же символы разделенные только пробелами. Все остальные символы считаются словами. Слов взять хотя бы 7 и разнообразных, для тестирования, от 1 символа, до нескольких. Сформировать массив char* words[], который состоит из этих слов, ввиде отдельных строк.
9.171-9.179 - исходные данные, это массив char* words[] из предыдущего задания. Вывести все слова в порядке нахождения их в предложении и длину каждого из них, можно еще и индексы в массиве тут же для удобства. Определить самое короткое и самое длинное слово в массиве, вывести их индекс, сами слова и длины. Вывести слова снова, но уже в порядке неубывания их длин, можно воспользоваться дополнительным массивом индексов, и заполнять его по мере поиска максимального и минимального. Метод простой вставки по сортировке. Вывести все уникальные слова и слова которые встречаются хотя бы дважды. Вывести также симметричные слова, написать функцию. Слова где все буквы, уникальны(дополнительно). Если получится оформить ввиде красивой таблицы, если не влезает, то просто последовательным выводом.
9.165-9.167 - реализовать по аналогии, как мы делали перестановки в строке по символам. Здесь только работать по словам, которые были сформированы в задании 1.164. Задать порядок ввиде массива индексов(пар индексов) и тремя способами переставить исходные слова в предложении. Можно также оформить через оператор switch красиво.
9.168-9.169 - объединить. Дан текст ввиде строки состоящий из слов, можно использовать разбор из предыдущих заданий; Дана вторая строка, которая содержит простые правила по поиску слов в предложении. Написать универсальный код, который будет интерпретировать правила и выводить результат на экран по поиску слов по критериям. Пример команд: char rules[] = "SgEnBaBwMa1Ll2Qe1". Допустимость пропустить. Пояснение аналогично условиям заданий. Или использовать свои произвольные команды и данные по вкусу. Вывести подсказку примерно.

printf("Format, command and data. 'S' - start char: char, 'E' - end char: char, "
       "'B' - both start and end char: char, 'M' - more than chars: char + digit, "
       "'L' - less than chars: char + digit, 'Q' - equal chars: char + digit.\n");


9.180-9.183 - дополнить задание 9.164, вторым предложением и соответственно выделить слова во второй массив words_2. Анализуруя слова в обоих, определить все типы слов по условиям задачи. Дополнительно можно выводить простым списком слова и все его характеристики, если использовать один цикл для всех заданий, они немного дублируют друг-друга.
9.186 - дана исходная строка текста, словом является всё то, что не разделено пробелом. В тексте отсутствуют табуляции, но есть перенос на следующую строку. Пробелы в произвольном порядке. Задана ширина поля текста. Вывести текст с учетом ширины поля и с переносом строго по словам, либо если слово не влезает в поле, то переносить по символовам. Реализовать четыре режима выравнивания текста, "слева", "справа", "по центру" и "по ширине". Пробелы для выравнивания добавлять равномерно между словами. Если пробелы не равны, то сделать красиво. Учесть абзацы и перенос строки, по желанию первое слово абзаца делать с отступом.
9.184-9.185 - немного модифицируем и усложним задание. Потребуется реализовать простой логический калькулятор для вычисления выражений, заданных ввиде текста. Из чисел/цифр только 0 и 1. Необходима поддержка всех основных операторов: логические "и", "или", "исключающее или" и "не", как и в си: "&", "|", "^" и "!". Поддержка до как минимум 4 вложенных скобок и контроль их упорядоченности и парности. Ошибку со скобками вывести подробно, где и на какой позиции не хватает. Порядок действий по правилам языка Си и математики. Контролем пробелов или посторонних символов пренебречь и просто вывести сообщение об ошибке, пробел только между операндами, скобки и цифры сплошным. "1 | 0 & ((1 ^ 0 & 1) | (1 & 1)) = результат".

 Глава 10. Функции и процедуры

 Часть из этих задач мы уже делали, поэтому если что пропускаем и функции тоже уже оформляли, так что больше для повторения материала. Для теории подготовить главу 9 в Прате и частично вопросы.

 Функции

 10.1-10.2 - одно задание на выбор, полностью все варианты; использовать одну универсальную функцию с параметрами, можно частично передавать данные через массив. Желательно подробный вывод автоматизировать через варианты, как и в задачнике. Можно использовать генератор случайных чисел.
 10.3-10.5 - простая, одну на выбор, полностью.
 10.6-10.11 - все кроме 10.8(дополнительно), постараться выделить функции как можно более универсальные для всех задач вместе. И комбинировать их по мере необходимости. Опечатка "AD" на "AC" стороны заменить.
 10.8 - желательно реализовать, т.к. часто встречаются.
 10.12 - обьединить в одну функцию, c рычагом типа вызова; вычислить количество четных и нечетных.
 10.13-10.14 - обьединить в одну, реализовав универсальную функцию с параметром степени.
 10.15-10.16 - вроде уже функция определения простоты числа была у нас реализована, если есть, то применить уже готовую. Если нет, то реализовать заново. Обе задачи полностью.
 10.17 - аналогично, функцию факториала уже делали, просто протестировать на заданном примере с данными конкретными числаим.
 10.18-10.19 - реализовать функцию по вычислению суммы и количества цифр в числе, по параметрам. Похожую уже делали, только оформить. Для дополнительного возврата параметров использовать взятие адрес параметра. int digits_in_num(int num, int start, int len, int* sum); Возврат, количество цифр в числе. Параметры: само число, стартовая цифра, количество цифр от старта и сумма по адресу(указателю). Протестировать, на паре простых чисел.
 10.20 - используя только предыдущую функцию, вычислить счастливые номера до предела разумного предела(до шести), все числа не выводить, только счастливые.
 10.21 - уже делали, пропускаем.
 10.22 - тоже уже вроде было ввиде макроса, но если не было такой функции, то реализовать функцию поиска максимального из двух чисел и для 6-10 чисел использовать массив для проверки.
 10.23 - была в 4-ой главе, но на календарь лучше повторить, поэтому оформить функцию красиво с учетом всех параметров дат(в т.ч. и года до нашей эры). Оформить функции: void next_day_date(int* day, int* month, int* year); void prev_day_date(int* day, int* month, int* year) и int is_leap_year(int year). Протестировать функции в таблице дат: февраль високосного и не високосного года, года 1900, 2000, и например 2020. А также через нашу эру. 1-ый год январь и предыдущий год, 31-ое декабря.
 10.24-10.27 - всё что свзяно с этим, уже точно делали раньше. Просто подготовь к демонстрации на вещании. Сокращения дробей разве что у нас не было вроде в отдельной функции оформлено, так что можно и их. 2-3 варианта для тестирования. 10.26-ую и 10.27-ую обьединить в одну, или одну из них реализовать, если покажется сложновато.
 10.28-10.31 - уже саму функцию делали по подсчету количества символов. Используя её, в трех предложениях(строках), вычислить количество вхождений заданного символа в каждой строке, общее количество и доли(показать в процентах) в каждом предложении и долю от общего количества символов во всех трех строках. Дополнительно используя там же функцию поиска индекса символа, определить, в какой строке заданный символ встретился первее остальных.
 10.32 - уже точно делали, пропускаем, ну или если есть желание дополнительно, то можно использую функцию, которую уже делали на палиндром, потестировать с 2-3 словами.

 Процедуры

 Здесь фактически только одно задание, но оно слишком простое, поэтому немного сделаем его универсальней и поинтересней. Рисование нашими командами и собственный простой интерпретатор.

 10.33-10.37 - дана условная доска размерностью 8*8, 16*16 - или любое другое число, но не слишком большое, чтобы удобно помещалось в ввывод на экран с учетом размера шрифта и отладки. Дана строка, которая состоит из команд позиционирования и рисования курсором условно графических примитивов и параметров в шестнадцатиричной форме. Во всех функциях предусмотреть проверку параметров на допустимость и вывод сообщений об ошибке. При выполнении функций выводить эхо команд ввиде текста и параметров, которые удалось достать по потоку. Символы-команды для рисования:
 "P" - позиционирование "карандаша" и сразу за ним две координаты в шестнадциричной форме. Например "P3A" - установить активные чернила на позицию 3 по горизонтали и 10 по вертикали.
 "D" - просто поставить точку в текущую координату.
 "H" - нарисовать горизонтальную линию до параметра горизонтальной позиции, сразу после буквы. Пример: "H5" - нарисовать горизонтальную линию от текущей координаты до координаты 5. Слева или справо. Вертикальная координату оставить такую-же.
 "V" - аналогично, только это вертикальная линия. Также до координаты.
 "R" - нарисовать прямоугольник, следующие две координаты являются другим углом относительно текущей позиции. Использовать команды горизонтальной и вертикальной рисовки линий или можно простыми циклами по желанию. Пример: "R5E" - от текущей позиции нарисовать прямоугольник, до координат 5, 14.
 Дополнительные команды чуть посложнее(хотя бы попробовать):
 "B" - нарисовать произвольную линию из текущей точки в заданную, используя алгоритм Брезенхэма.
 "T" - изобразить треугольник, параметров после 4, это координаты двух других вершин.
 "C" - нарисовать окружность из текущей позиции (центра) и параметром радиуса.
 Изобразить комбинацию фигур на плоскости, можно ввиде любой фантазии. После исполнения всех команд, заполнить линейный массив из символов по размерности равный всему полю и вывести ровно на экран квадрат X*Y, где все отрисованные точки отобразить ввиде знаков "*", остальные можно "." или оставить пустыми и вывести индексы все по краям в буквенной форме(A..Z), примерно как поля.
 10.38 - небольшая, но мы похожую уже делали в самой первой главе, просто символично оформить в функцию. Можно использовать параметры типа int, char - по вкусу.
 10.39-10.40 - уже делали, и кажется во второй главе. Если есть желание для закрепления материалов реализовать или пропустить.

 Рекурсия

 Для рекурсии общая рекомендация быть внимательней, не выходить на большую глубину вызовов, подбирая параметры заданий и данные, таким образом, чтобы можно было отследить ход выполнения программы и легче отладить. При каждом вызове функции, дополнительно, можно выдать в консоль информацию о вызове и параметрах и даже дополнительно статичный счетчик. Если аналогичные функции уже были реализованы, то можно оставить то же самое название и дополнить "_recur" в названии.

 10.41-10.42 - уже точно делали, но если не делали этого рекурсивно, то реализовать оформить обе функции кратко. Возведение в произвольную степень можно оставить целочисленным по параметрам и результатам. Проверить входные данные на минимальную допустимость и простые правила арифметики(0-ая степень, 0 в степене и т.д.).
 10.43-10.44 - классика, частично уже делали, оформить полностью обе. В 10.44 использовать функцию из 10.43, значение количество цифр можно передавать как через возвращаемое значение, так и через статичную переменную.
 10.45-10.46 - одну на выбор, просто достаточно. Последовательность проверить короткой на 3-5 элементов. Реализовать каждую функцию по отдельности или одну функцию на оба варианта. Можно использовать передачу дополнительного параметра по адресу.
 10.47 - тоже классческая, реализовать, много строк не займет. Два или более параметров можно передать по адресу/указателю.
 10.48-10.49 - объединить в одну, один или оба параметра, максимальный элемент - возвращаемое значение, его индекс или текущий индекс можно передать по адресу и использовать его между вызовами. Как удобней.
 10.50 - тоже классика, параметры более 3 не считать, вывод чуть подробнее, ввиде маленькой таблицы параметров функции Аккермана(m, n), для проверки можно заглянуть в Вики.
 10.51 - кажется задание устное, если что просто озвучим на вещании, посмотреть и максимум прикинуть на бумаге.
 10.52 - дополнить одну из первых функций, параметром "направления" вывода цифр в числе или если удобней, то написать функцию заново. Реализовать функцию только на вывод или с возвратом целочисленного результата по жеалнию. Не применять строки, только арифметику.
 10.53 - аналогичная, пропускаем, т.к. еще и есть ввод с клавиатуры.
 10.54-10.55 - объединить и реализовать одну универсальную функцию перевода числа из любой системы счисления в любую; основание систем счисления от 2 до 16 включительно. Добавить контроль данных и не использовать вспомогательные функции. Рекурсивно. Результаты перевода систем счисления можно представить в таблицу со основаниями из 10-тичной в 2,8,16-ти ричную и обратно для проверки.
 10.56 - не очень сложная и уже делали. По возможности использовать по минимум дополнительных параметров, если не получается, то можно применять и адреса параметров для удобства.
 10.57 - тоже функция была, только теперь её нужно рекурсией реализовать. Не забыть проконтролировать входные данные на допустимость и можно еще учесть условно максимальную длину нашей строки.

