 Общие рекомендации для решения задач, книга - Златопольский Д.М. Сборник задач по программированию, 3-е задание. 

Глава 1. Ввод и вывод числовых данных. Опертор присваивания.


 Простейшие программы. Арифметические выражения.

 В этом разделе скорее важно попробовать запустить среду разработки, настроить проект и скомпилировать код. Попробовать первые запуски программ.

 1.1-1.13 - четные или нечетные на выбор, если есть варианты, то варианты все.
 1.14-1.17 - в каждом задании выбрать 3-4 варианта поразнообразней, использовать функции математической,и блиотеки math.h можно посмотреть в справочнике.
 1.18-21 - четные или нечетные на выбор, достаточно одного варианта в каждом задании.

 Вычисления по известным формулам.

 Здесь много типовых заданий, которые попадются на разного рода практических, контрольных и прочих лабораторных.

 1.22-23 - один вариант или оба по вкусу.
 1.25-29 - полностью, не сложные, но часто встречающиеся.
 1.30 - один вариант на выбор.
 1.31 - очень популярная, оба варианта.
 1.35-37 - придеться немного вспомнить геометрию.
 1.39-42 - любую одну на выбор но все параметры.
 1.44-1.51 - четные или нечетные на выбор.
 1.52-1.54 - одну на выбор, арифметика.
 1.55-56 - одну на выбор, задача на движение.
 1.57-58 - обязательно(58-ая часть её), т.к. будет в КиР.

 Часто используемые алгоритмы.

 1.59-1.60 - обе, т.к. типовой алгоритм обмена переменными.
 1.61-1.62 - 2-3 на выбор из каждой.


Глава 2. Целочисленная арифметика.


 Простейшие задачи: 2.1-2.4 - одну на выбор; 2.6 - полностью на время; 2.8-2.9 - одну на выбор.

 Выделение цифр в записи числа: 2.12-18 - обязательно, для вычислений и закрепления последовательности действий, можно оформить как одно задание и объединить; 2.21-23 - одну по желанию дополнительно(или можно пропустить).

 Нахождение целого числа по информации о его цифрах: 2.24-2.33 - три-пять на выбор, число Н другие параметры вводить с клавиатуры не надо, просто задать его как переменную. Оставить подробнее комментарии как именно было решено, т.к. задания могут показаться немного запутанными.

 Задачи повышенной сложности. 2.34-36 - любая полностью; 2.37-38 - одна на выбор. 2.39-42 - запутанно, но одну на выбор, если получится дополнительно посмотреть. 2.43 - попытаться применить хитрость. :). Все задачи повышенной сложности либо делать подробнее вывод в консоль, что происходит, либо снабжать текст комментариями. В задачах на последовательности активно применять целочисленную арифметику.


Глава 3. Величины логического типа.

 В этой главе для классического Си удобно использовать переменную целочисленного типа и определять значения истины как 1, ложь - как 0. Вывод подробнее в консоль. В других языках программирования можно использовать специальный логический тип по стандарту.

 Вычисление логических выражения. 

 3.1-3.10 - четные или нечетные по выбору, все варианты.
 3.11-3.12 - одну на выбор, любые 2-3 варианта.
 3.13-3.26 - любую каждую третью(14,17,20,23...), все варианты в выбранных.

 Составление логических выражений.

 3.27 - минимум три любые варианта на выбор.
 3.28-3.31 - четные или нечетные по выбору, все варианты.
 3.32-3.33 - одну на выбор, подробнее вывод в консоль(можно просто ссылку на рисунок).
 3.34-3.35 - по 3-4 варианта разнообразней из каждой реализовать, они небольшие. Заглянуть в Вики, чтобы уточнить правила шахмат. Также можно уже начать набрасывать общую модель для игры в шахматы, после будем её дополнять.

 Не хватает в репозитории. 3.1-3.10. чет/нечет. 11-12 - есть; 3.13-3.26 - просто переставить по порядку и еще одну для комплекта реализовать. 3.28 или 3.29 - любую полностью, с выводом вычислений.


Глава 4. Условные оператор.


 Условный оператор и его различные формы. Там где возможно использовать полную форму оператора вместо нескольких. Если слишком длинные условные выражения, то либо разбить их на несколько строк или несколько операторов, главное чтобы было понятно и читабельно для нас.

 Полный условный оператор.

 4.1-4.2 - одну на выбор;
 4.5 - оба варианта;
 4.6-4.12 - три любые по выбору;
 4.13-4.14 - обязательно, обе полностью, т.к. часто попадается;
 4.15 - не совсем ясно почему здесь стоит применять условный оператор, но на вещании мы её сделали, по желанию;
 4.16-4.17 - одну на выбор, оба варианта;
 4.18-4.19 - одну на выбор, по желанию или если требуется потренироваться на олимпиаду.

 Целочисленная арифметика и условный оператор.

 Хм, эту часть мы решали во второй главе очень активно, но для закрепления желательно реализовать, т.к. будут как раз комбинации целочисленной арифметки и условных операторов.

 4.20-4.22 и 4.34 - объединить в одно задание вывести все результаты анализа числа сразу;
 4.23-4.26 - одно задание на выбор, но все варианты;
 4.27-4.31 - также одно задание на выбор, аналогичное преыдущему;
 4.32-4.33 - их уже желательно реализовать с помощью циклов, так что лучше их пропустить, или по желанию;
 4.35-4.36 - классика, постараться сделать обе.

 Использование сложных условий.

 4.37 - после проверки если что закомментировать ввод, чтобы каждый раз не вводить при тестировании;
 4.39 - попробовать значения переменных, чтобы попасть во все области на рисунке и протестировать все ветки;
 4.40-4.41 - одна на выбор, использовать вещественные переменные;
 4.42-4.45 - все, но использовать одни и те же переменные(можно разные значения) и постараться реализовать более сложные компактные условия;
 4.46-4.47 - одну на выбор, немного вспомнить формулы;
 4.48 - аналогична, пропускаем;
 4.49 - обязательно, распространенное задание на разного рода лабораторных;
 4.50-4.53 - нечетные номера, быть внимательным с параметрами;
 4.55-4.60 - одна на выбор, оба варианта, уже делали много похожих в предыдущей главе;
 4.61 - обязательно, часто встречаемая;
 4.62-4.64 - одну на выбор, цифры выделенные можно сохранить в отдельные переменные;
 4.65 - обязательно, пригодиться в работе, календарь часто сложнее чем кажется;
 4.66-4.69 - чуть сложнее, дополнительно, хотя бы попытаться решить.

 Неполный и вложенные условные операторы.

 4.70-4.71 - одну на выбор, выполнить все варианты, с подробным выводом по какой именно ветки условия мы прошли;
 4.72-4.73 - дополнительно, для заркепления, можно пропустить;
 4.74-4.75 - одну по выбору, не перепутать знаки и использовать вещественные переменные;
 4.76-4.78 - обьединить в одну сразу по всем трем параметрам, не использовать ввод с клавиатуры;
 4.79-4.80 - также объединить решение как одну, все варианты;
 4.81-4.84 - аналогичны предыдущим, можно пропустить;
 4.85-4.90 - четные или нечетные на выбор, можно оформлять более сложными логическими выражениями по желанию;
 4.91-4.93 - одну на выбор, предпочтительней 91-ая, все варианты(а-в);
 4.94-4.103 - четные или нечетные на выбор, цикл не использовать, вывод более краткий для закрепления.

 Оператор выбора варианта.

 4.110 - полностью;
 4.111 - дополнительно по желанию, пример с календарем, т.к. уже это задание было.

 Задачи повышенной сложности.

 Все задания в этом разделе делать по возможности, но желательно разнообразно.
 
 4.116-4.118 - по возможности постараться решить 4.118, если не получается, то одну любую на выбор;
 4.119-4.120 - попробовать 4.120, каждый четвертый вариант со всеми параметрами, если трудно, то 4.119 - все варианты интерпретация "хода" свободная;
 4.121 - дополнительно, можно пропустить;
 4.122-4.124 - попытаться объединить в одну, вспомнить формулы;
 4.125-4.128 - одну на выбор, которая удобней, вывод формы слов можно реализовать транслитерацией;
 4.129-4.131 - аналогичные, только если захочется закрепить материал, в остальном пропустить;
 4.132 - любопытная задача, попробовать решить, помнить про часы и ход времени;
 4.133-4.134 - только 1.134, в следующих главах оформим функцию, запасная задача 4.133;
 4.135 - светофор, классика, полностью;
 4.136 - уже была, если есть желание, то повторить;
 4.137-4.140 - одну на выбор, без строк;
 4.141 - относительно простая.

 Далее просто списки заданий для первого вещания, требуется обновить по мере продвижения.

 С 90-ой задачки, нам рассказать на вещании.

 Задачи выбранные и фактически решенные на вещании: 4.125; 4.128; 4.132; 4.134-135; 4.140-4.141. 
 Задачи решенные мною по ходу планирования: 4.118, 4.119, 4.125, 4.128, 4.132, 4.134, 4.135, 4.140.


Глава 5. Оператор цикла с параметром.


 Организация вывода данных по требуемому формату: 5.3 - полностью все варианты, обьединить всё в одну большую таблицу, параметры А и Б просто задать и размер таблицы ограничить на 5-7 строк в итоге(можно использовать табуляции или пробелы и формат через поля принтф); 5.8-5.10 - все, и так же можно обьединить в один цикл и одну большую таблицу построить(шапку таблицы не забыть), но можно и по отдельности; 5.11-5.12 - любая на выбор; 5.15 - можно просто в строчку вывод сделать, без клавиатуры; 5.16-5.26 - четные или нечетные по выбору, также можно объединять в одну таблицу, если удобно.

 Обработка фиксированной последовательности чисел: 5.27-5.30 - одну на выбор, но все варианты, значения задавать переменной; 5.31-5.35 - сделать все, но попробовать использовать один цикл по Н и можно условные операторы, вывести суммы уже после цикла, если не получается, то через циклы на каждую задачу, причем если Н меньше чем по условию, то можно сделать последовательность чуть короче, но минимум 3 элемента должно быть в каждой из них. Результаты по элементам и сумме удобней представить в типе double.

 Обработка данный во время ввода: 5.39-5.56 - каждую 3-ую задачу, использовать генератор случайных чисел для всех задач в этом разделе; 5.57-5.65 - каждую 3-ую тоже. Если где-то не указано количество элементов, то минимум использовать 3-7 элементов.

 Рекуррентные соотношения: это полезный раздел как на практике, так и потом пригодится нам для изучения. 5.66-5.76 - все задачи по возможности, но если есть варианты, то можно ограничиться только одним в задании. Все задания разворачивать последовательность через пробел в консоль. Индексы можно записывать в виде A[k], A[n+1] и т.д. Дроби представлять ввиде целочисленной пары числителя и знаменателя.

 Расчет площади кривой: простые численные методы, одна по желанию, но так-то существуют более общие алгоритмы.

 Разные задачи: 5.81-5.85 все подряд; 5.86-5.96 - четные или нечетные на выбор; в этом разделе постараться оформить вычисления ввиде отдельных функций.

 Общие рекомендации: использовать для последовательностей заданных с клавиатуры(или просто случанайных цифр) значений генератор случайных чисел.

printf("Example of random sequence, #include <stdlib.h>: ");
srand(0);   // Инициализация последовательности случайных чисел любым другим значением.
for (int i = 0; i < 10; ++i) {
    int a = rand() % 100;   // Генерируем числа от 0 до 99.
    printf("%d ", a);
}
printf("\n");


 Глава 6. Операторы цикла с условием.


 Обработка числовых последовательностей. 6.1-6.21 - каждую третью на выбор, для последовательностей использовать или генератор случайных чисел или простые правила. В последовательностях удобней применять ограничения достаточные для тестирования алгоритма, не слишком длинные, но и не короткие.

 Использование условного оператора в теле операторов цикла с условием. 6-22-6.42. Каждую третью по выбору. Слишком длинные последовательности желательно не выводить или выводить в строку, через любой разделитель, "запятая" или "пробел". 6.43-44. Задачи объединить в один цикл и сделать все вычисления рядом. Использовать можно простые целые числа, вместо вещественных и простой генератор через сложение, чтобы получалась последовательность не возрастающих чисел. Также можно посчитать частоту вхождения чисел в последовательность. Использовать при этом пару целочисленных массивов для удобства. 6.45. - классика, реализовать на основе описания алгоритма и оформить в отдельную функцию с тестированием нескольких вариантов.
 
 Использование условного оператора после операторов цикла с условием. 6.46-6.75 - каждую третью на выбор, все варианты, если их несколько. Там где ограничения по числу слишком велики или последовательность слишком длинная, то по использовать минимальные параметры для проверки. 6.52 - можно простым перебором в цикле, классические алгоритмы оставим на десерт. 6.76-6.79 - оформить ввиде функций, которые возвращают integer - позицию искомого элемента последовательности или -1, если элемент не найден. Параметры прогрессий вводить ввиде переменных на вход функции; для 6.76 - можно сделать одну универсальную функцию, а не две разных.

 Использование условного оператора в теле операторов цикла с условием и после него. 6.80-6.87 - каждую вторую на выбор.

 Разные задачи. 6.88-6.90 - одну на выбор; 6.91 - полностью, оформить ввиде функции; 6.92-93 - одну на выбор, можно использовать целочисленные массивы или простую последовательность; 6.94-95 - одну на выбор; 

!Исправить эти, либо выкинуть либо убрать массивы, аналогично.

6.96-6.97 - по желанию одну на выбор, использовать массивы, в последующих главах где будет поиск/массивы будут аналогичные; 

6.98-6.101 - уже делали в предыдущих главах, так что по желанию или пропускаем; 

6.102-6.103 - классика, обязательно, оформить функцией с подробным выводом в консоль и передачей параметров по адресу;

! 103 - возможно без вызова как есть.

6.104-6.105 - одну на выбор; 

6.106-6.111 - все, можно обьединять некоторые задачи; 6.112-6.114 - часть уже делали, так что любые по желанию или можно пропустить; 6.115 - попробовть один вариант, может пригодиться дальше.


 Глава 7. Сочетание оператора цикла и условного оператора.


 Во всей главе не вводить данные вручную с клавиатуры, а использовать генерацию данных похитрее.

 Простейшие задачи: 7.1-7.12 - любые четные или нечетные по выбору; 7.13 - полностью все варианты, разложение на делители сделать более подробно;

 Организация вычислений во время ввода данных: 7.14-7.17 - все примерно одинаковые, четные или нечетные по выбору, можно в одном цикле оформить; 7.18-7.20 - одну на выбор; 7.21-24 - одну на выбор; 7.25-32 - частично мы уже далали подобные, поэтому 2 любые, через 4, на выбор; 7.33-37 - все задания объединить в одно, использовать только целые числа(не вещественные), последовательность генерировать на лету или в массив по вкусу; 7.38 - не совсем ясно в чем именно задача, но может еще посмотрим; 7.39 - мы уже делали пожожую, но тогда пришлось разбирать на вещании, попробуй сделать самостоятельно, это часто распространенная задача относительно физики; 7.40-42 - одну на выбор, простая; 7.43-7.46 четные или нечетные на выбор; 7.47-48 - аналогичные, только с более реальными примерами, по желанию одну для наглядности или можно пропустить; 7.49-51 - одну на выбор, применить генератор похитрее, если получиться, т.е. ввести счетчик или флаг, при обработке которого нужные числа будут сгенерированы(можно через увеличивающийся шанс).

 Определение максимального и минимального значений во время вввода данных: 7.52-7.57 - каждую третью, на выбор, использовать генерацию последовательностей; 7.58-7.59 - одну на выбор с выводом исходных данных и результатов вычислений; 7.60-7.63 - одну на выбор, можно с массивами или просто последовательностями; 7.64-7.66 - одну на выбор; 7.67-7.72 - каждую третью на выбор; 7.73-7.76 - одну на выбор, все варианты, в один цикл; 7.77 - не понятно, что именно требуется может обсудим; 7.78-7.79 - одну на выбор; 7.80-7.83 - все полностью, можно применять массивы или без них(82 и 83 можно обьединить); 7.84-85 - уже частично делали ранее, только если будет желание.

 Использование условного оператора после оператора цикла: 7.86-7.89 - объединить все вопросы в одну задачу, последовательность целочисленная; 7.90-7.93 - одну на выбор; 7.94-7.95 - тоже одну на выбор.

 Использование условного оператора в теле оператора цикла с условием и после него: 7.96-7.100 - одну на выбор, или можно объединить пару для разнообразия; 7.101-7.102 - одну на выбор, аналогично, но одним циклом; 7.103-7.108 - каждую третью на выбор; 7.109-7.110 - либо теоретически ответить, либо одну на выбор с демонстрацией; 7.111-7.116 - каждую третью на выбор; 7.117-7.118 - одну на выбор(обьединить с предыдущими); 7.119-7.123 - одну на выбор, часть уже была; 7.124-7.125 - обьединить задания, но они и так частично совпадают; 7.126-7.127 - оформить вспомогательные функции для каждой задачи, это дополнительные задания, если что разберем их вместе часть уже была; 7.128 - обязательно, т.к. она часто встречается.

Даниил и все. Дополнительное задание от ScriptedEngineer. Даны целые числа в произвольном диапазоне(возьмем наверное просто от 0 до 255). Вывести на экран те из них, которые в бинарном(двоичном) виде являются палиндромами, т.е. читаются одинаково слева-направо и наоборот.
Оформим отдельной функцией все это в стиле void scripted_engineer_1(). Отдельно также сдалаем функцию перевода целого unsigned char в строку, т.е. void to_binary(unsigned char byte, char string[]). Использовать будем именно массив char[] или строку, не int, как мы переводили до этого.


 Глава 8. Вложенные циклы.


 В всей главе быть осторожным с составным оператором и оформлением отступов. Там где есть параметры в заданиях, стараться использовать оператор for, там где есть простые условия, то лучше while оператор. Ввод с клавиатуры заменить на генерацию последовательностей.

 Организация вывода с использованием вложенных циклов: 8.1-8.8 - каждую четвертую на выбор, все варианты; 8.9-8.10 - одну на выбор, сделать два вывода алгоритмически.

 Обработка данных во время ввода с использованием вложенных циклов: 8.11-8.22 - каждую 3-ую, все варианты, если таблицы очень большие, то уменьшить количество строк(записей) и уплотнить вывод; 8.23 - полностью, все варианты поподробнее; 8.24 - дополнительно по желанию.

 Вложенные циклы и целые числа: 8.25-8.38 - построить таблицу делителей чисел от 1 до n(можно небольшое), с выводом всех делителей до 1 и их общее количество. Вывести общее количество чисел, количество делителей которых равно k, можно отметить их по ходу вывода таблицы столбцом или уже после таблицы по вкусу. Найти числа, которые имеют максимальное и минимальное количество делителей. Вывести сумму делителей и отметить те из них, которые кратны m, а также числа с минимальной и максимальной суммой делителей. Отметить те числа в таблице, которые являются простыми и совершенными, можно использовать наши предыдущие функции. Определить пары всех дружественных чисел, суммы делителей которых равны между собой; 8.39-8.40 - одну на выбор; 8.41 - можно немного снизить поиск параметра решений с 30 до 10; 8.42-42 - одну на выбор, можно применять битовые операторы; 8.44-45 - одна на выбор, через циклы, без арифметики; 8.46 - пропускаем, уже делали.

 Дополнительные задания повышенной сложности. 8.50 - похожая задача, но можно применить сдвиги по номиналу монет, вывода сделать по нескольким n и подробно, сколько купюр и какого достоинства используются, посчитать контрольную сумму, подумать над доказательством минимальной комбинации. 8.51 - интересная задача, можно даже будет позже оформить в отдельную функцию и дополнительно рискнуть применить рекурсию. От произвольного числа до одной цифры, через последовательное вычисления. Описать все этапы в консоли. 8.53-8.54 - только второй вариант, либо записать в формате "множитель:количество", используем нашу функцию простоты числа, объединить в одно задание; 8.55-8.57 - относительно простая, применить поиск НОД по Евклиду и ввести параметр p, а не n для поиска взаимной простоты; 8.56 - не совсем ясно условие, так что пропускаем или еще подумаем; 8.58 - не совсем понятно что именно подразумевается под "способами", но если в протом виде, найти просто кубы слагаемых, может еще подумаем; 8.59 - вот как раз на рациональные числа, задать дроби и поискать среди них, шаг числителя и знаменателя 1, и возможно лучше будет задать ограничитель произвольный, не только 7.


 Глава 9. Строки символов.


 В этой главе стоит реализовывать все необходимые функции самостоятельно, стараясь не использовать встроенные библиотечные функции. Можно дополнить функции дополнительными проверками на допустимость параметров. Для Си это классический массив char, для остальных языков можно выбирать по вкусу. Также пробежаться по теоретическим вопросам в начале главы. В книге Праты, главы 4 и 11 прочитать и/или повторить.

 Простейшие задачи. 9.1-9.5 - одну на выбор, можно сначала сделать с вводом с клавиатуры, а потом закомментировать и подставить для ускорения вывода простую переменную; 9.6 и 9.11 - можно обьединить или реализовать только одну; 9.7-9.10 и 9.12 - обьединить все задания в одну; даны 3 строки(можно названия городов или любые), и выполнить действия из всех задач для этих 3-ех строк, желательно часть оформить ввиде кратких функций - вычисление длины строки и обмен содержимым двух строк, если потребуется; int string_length(char s[]) и void string_exchange(char s1[], char s2[]).

 Работа с символами строки. 9.13-9.21 - каждую 3-ую задачу на выбор, индексацию символов удобней вести с 0; 9.22-9.23 - одну на выбор; 9.24-9.30 - обьединить в одну, взять 3 слова на английском и получить вырезкой и вставкой других 1-3 слова на английском, слова подобрать покороче и использовать простые методы без автоматического поиска, просто подставив буквы, реализовать дополнительно функцию - копирование подстроки из строки int string_copy_substr(char src[], char dst[], int start, int length); 9.31-9.36 - взять также 3-5 строк и произвольные слова, получить 1-3 иных английских слов путем замены букв, пары "поиск-замена" можно занести в массив или в ручную, реализовать дополнительно функцию поиска индекса буквы в строке int string_find_char(char src[], char c); 9.37-9.40 - реализовать универсальную одну функцию, которая делит строку на равные части, а потом меняет их местами в строке, простым перемешиванием или иным способом, можно дополнить еще способом прямого, обратного или чет/нечет и т.д. Порядок символов в частях сохранить, работать внутри исходной строки. Дополнительно для сложности можно использовать только один символ для обмена.

 Обработка строк с использованием оператора цикла с параметром. 

 Эту часть мы случайно проскочили мимо, но если что тут стоит поработать без использования функций, которые мы реализовали уже в следующей части. Простые циклы и работа с индексами символов.

9.41-9.42 - дана строка, вывести её столбиком и в обратном порядке.
9.43 - дана строка, вывести четный или нечетный порядок следования символов на выбор. 
9.47 и 9.49 - дана строка, добавить к слову символ A, количество N, задать параметры по выбору.
9.50 - как есть, параметрами сделать позицию старта и длину замены символов, не забыть проверить на допустимость.
9.51-9.65 - дана строка, вывести: заданные символы из второй строки и все их позиции, символы уникальны, количество различных символов можно задать параметром или искать все, до конца строки; посчитать общее количество каждого найденного символа и  долю от обшего поиска (N/M) всех найденных символов; вывести каждый N символ в строке; также посчитать количество последовательностей соседних равных символов и их индексы, задать количество соседних; исходную строку можно взять подлинее.
9.66-9.74 - дана строка текста, словом называется последовательность символов между символами разделителями. Символы разеделители пока что: пробел, новая строка и табуляция. Посчитать количество слов и дополнительно попробовать отформатировать заданный текст, ограничив длину строки в N символов и реализовав перенос по словам, пробелы, табуляции, переносы строк оставить в потоке символов и если слово длинней ширины, то печатать просто по символам как есть без переноса. Если ширина поля менее одного размера табуляции, то просто оставить пустую строку. // только с этой строкой.

 Обработка строк с использованием операторов цикла с условием.

 В этом разделе мы немного изменяем задания и разрабатываем универсальные функции для работы со строками.

9.75-9.77 - написать функцию поиска символа в строке. На входе строка, символ, направление поиска(с начала или конца) и флаг вывода символов во время поиска на экран. На выходе индекс первого найденного символа или -1, если символ не найден. int string_char_find(char s[], char c, int direct, int debug), протестировать функцию в разнообразных вариациях входных данных; 9.78 - уже кажется делали, но только для числа, если не делали для строки, то сделать функцию на проверку строки на палиндром; 9.79 - написать функцию подсчета количества заданного символа в строке. На входе строка и символ, на выходе - количество символов или нуль, если символов не найдено(вроде мы уже делали такое, так что можно просто вызвать/скопировать/модифицировать) int string_char_counter(char s[], char c); 9.80 - написать функцию определения последовательности одинаковых букв в строке с определенного символа и заданной длиной, на входе строка, символ, стартовый индекс и длина последовательности; на выходе 1 - есть совпадение, 0 - нету совпадения по всей требуемой длине; int string_find_seq(char s[], char c, int start, int length). 9.81 - модифицировать нашу функцию определения равнозначности строк, если строки равны, то вернуть 0, если больше 0, то это вернуть количество первых символов, которые совпадают в строках, но не полностью и -1, если не один из символов не совпал(чуть подкорректировать предыдущую задачу). 9.82-9.84 - часть тестирования предыдущих функций, поэтому пропускаем(пара символов это последовательность из 2 одинаковых); 9.86-9.87 - написать функцию поиска подстроки в строке, пока что простой вариант, int string_find_sub(char s1[], char s2[]), -1 - если не найдена строка полностью; 0 или более - индекс найденной подстроки в строке. И функцию замены всех подстрок в строке на другую подстроку или сделать рычаг управления. На вход исходная строка, подстрока для поиска, подстрока для замены и флаг замены всех или только первого попавшегося. На выход: количество фактических замен. int string_replace_sub(char src[], char find[], char replace[], int all); - протестировать на паре примеров. 9.88-9.89 - реализовать используя комбинации предыдущих функций и проверить.

 Изменение исходных строковых величин

 В этом разделе все операции должны производиться внутри исходной строки, дополнительные строки желательно не использовать, или максимум временно, но вернуть в итоге измененную исходную строку. Использовать по возможности функции, которые были разработаны в предыдущем разделе. Хм, стоит подумать над заранее подготовленными данными для проверки.

9.90-9.91 - дана исходная строка и строка содержащая символы пар поиск-замены, char [] = { 'a', 'b', 'e', 'f'} и тд или в обычную строку(четные-нечетные) всё вместе. Используя функцию поиска символа в строке string_char_find(...), осуществить замену всех символов заданных в парах.
9.92-9.93 - дана исходная строка и строка вида char[] c парами типа "'символ', интервал", char[] = { 'a', 2, 'b', 5}. Не используя дополнительных функций, заменить все K-символы интервала в исходной строке на символ в таблице.
9.94-9.99 - дана исходная строка, и массив слов вида char* words[]. Применяя функцию поиска подстроки в строке, заменить искомое слово на второе слово в паре, массива words[], при этом известно что длина слов в паре одинкова.
9.100-9.102 - дана исходная строка и массив пар индексов int[], поменять местами символы в строке, по соотвествующим парам индексов, оформить ввиде функции string_xchg_chars(char src[], int table[], int count), где count - количество пар, которые необходимо поменять. Тестирование функции в следующих заданиях.
9.103-107 - используя функцию из предыдущего задания реализовать генератор последовательностей замены символов в исходной строке, по таблицам. В таблицы в ручную не задавать. Строку взять хотя бы из 15 символов по минимуму. 103 - заменить символы в парах 1-2, 3-4, ... n-(n+1). 104 - перевернуть строку в обратном порядке таблицей, 1-n, 2-(n-1), ... (n/2)-(n/2). 105-106 - одной тоже прямо тексту, задать параметры. 107 - использовать предыдущую функцию поиска символа в строке.
9.108-9.112 - реализовать функцию удаления символов из строки, не забыть проверить всё на допустимость и правильно обрезать по новому размеру, на выход отправить код ошибки. int string_delete(char src[], int start, int length);
9.114 - классическая задача, реализовать полностью, исходная строка подлинее и генерируется случайным образом. Можно даже вывести количество итераций, которое потребовалось условно алгоритму на сравнения/замены и какие именно по индексам символы были удалены.
9.115-9.117 - пропускаем, уже реализовали функцию удаления символов и проверку строки на палиндром делали главами ранее.
9.118-9.123 - дана исходная строка c минимум тремя словами и словарь из отдельных слов char* words[]. Реализовать функцию вставки подстроки в строку, со смещением оставшихся символов, не перезаписывая исходную строку и скоректировав размер. Вернуть код ошибки. int string_insert(char dst[], char ins[], int start).
9.124-9.137 - дана строка состоящая из слов с условными ошибками, разделенные только пробелами. Взять 3-5 слов хотя бы. И дан словарь char* dict[], с правильным написанием тех же слов. Выделить слова из первой строки, определить совпадение(количество равных букв), и если количество совпадений по буквам более чем параметр доли N, то заменить это слово на словарное, длина слов в тексте и словаре должна совпадать. Неверные буквы в исходной строке можно выделить заглавными.
9.124-9.137 - написать две функции циклического сдвига символов в строке, void string_rlc(src[], int counter); void string_rrc(src[], int counter). На вход: строка исходник и количество сдвигов. Символ, который выходит за пределы строки, пенеоситься в последнюю или первую позицию строки.

 Обработка цифр в строке

 Здесь первые задания можно сделать без применения функций, т.к. они краткие. Но последующие уже можно с функциями.

9.138-9.141 - полностью, обьединить все задания в одну, не применять функции. Вывести: является ли символ цифрой, вывести эту цифру, вычислить количество цифр, сумму этих цифр и максимальную среди них.
9.142-9.144 - реализовать функцию преобразования строки в число, основания системы счисления использовать от 2 до 16. Если вместе с цифрами попадаются буквы, то их пропустить. Если ни одной цифры не попалось, то просто вернуть нуль. int string_to_int(src[], int base). Протестировать на нескольких примерах и на системах счисления с основаниями 2,8,10,16. int int_to_string(dst[], int num, int base). Не забыть наличие знака. И пару функций с тернарным оператором в дополнение, char upppercase(char c) и функция void string_reverse(char src[]). Uppercase - должна занимать одну строчку, использовать тернарный оператор.
9.147 - можно чуть более подробнее вывод, в качестве разделителя использовать знак + или -.

 Задачи повышенной сложности

 В этом разделе активно использовать предыдущие функции. 

9.152-9.153 - дана строка предложение, найти наибольшее количество идущих подряд одинаковых символов.
9.154-9.155 - исходная строка содержит текст, определить какие уникальные буквы в нем есть, и сколько их в строке.
9.156-9.159 - дано два слова, строки 1 и 2, в одно задание. Определить какие буквы первого слова входят во второе слово, какие буквы второго слова входят в первое и их количество, повторояющиеся буквы не учитывать. Определить буквы, которые есть только в одном из них. Определить буквы, которые встречаются в обоих словах.
9.160 - так же, два слова в паре строк. Оба варианта реализовать. Строгое и не строгое совпадение. Минимальный набор для тестирования удобней организовать парами слов. Среди них пара в которой не совпадает ни один символ, где есть не строгое и строгое соответствие по поиску. Пример: "char* word_pairs[] = { "blue", "cyan", "magenta", "tag", "red", "deer" };".
9.161-9.163 - задания аналогичны предыдущим, если требуется еще практика, то можно и их тоже решать.
9.164 - это достаточно большое задание, если от него стартовать. Поэтому возьмем его с учетом объединения с последующими. Далее по тексту. Дана строка предложение, которая состоит из слов. Слова это всё так же символы разделенные только пробелами. Все остальные символы считаются словами. Слов взять хотя бы 7 и разнообразных, для тестирования, от 1 символа, до нескольких. Сформировать массив char* words[], который состоит из этих слов, ввиде отдельных строк.
9.171-9.179 - исходные данные, это массив char* words[] из предыдущего задания. Вывести все слова в порядке нахождения их в предложении и длину каждого из них, можно еще и индексы в массиве тут же для удобства. Определить самое короткое и самое длинное слово в массиве, вывести их индекс, сами слова и длины. Вывести слова снова, но уже в порядке неубывания их длин, можно воспользоваться дополнительным массивом индексов, и заполнять его по мере поиска максимального и минимального. Метод простой вставки по сортировке. Вывести все уникальные слова и слова которые встречаются хотя бы дважды. Вывести также симметричные слова, написать функцию. Слова где все буквы, уникальны(дополнительно). Если получится оформить ввиде красивой таблицы, если не влезает, то просто последовательным выводом.
9.165-9.167 - реализовать по аналогии, как мы делали перестановки в строке по символам. Здесь только работать по словам, которые были сформированы в задании 1.164. Задать порядок ввиде массива индексов(пар индексов) и тремя способами переставить исходные слова в предложении. Можно также оформить через оператор switch красиво.
9.168-9.169 - объединить. Дан текст ввиде строки состоящий из слов, можно использовать разбор из предыдущих заданий; Дана вторая строка, которая содержит простые правила по поиску слов в предложении. Написать универсальный код, который будет интерпретировать правила и выводить результат на экран по поиску слов по критериям. Пример команд: char rules[] = "SgEnBaBwMa1Ll2Qe1". Допустимость пропустить. Пояснение аналогично условиям заданий. Или использовать свои произвольные команды и данные по вкусу. Вывести подсказку примерно.

printf("Format, command and data. 'S' - start char: char, 'E' - end char: char, "
       "'B' - both start and end char: char, 'M' - more than chars: char + digit, "
       "'L' - less than chars: char + digit, 'Q' - equal chars: char + digit.\n");


 9.180-9.183 - дополнить задание 9.164, вторым предложением и соответственно выделить слова во второй массив words_2. Анализуруя слова в обоих, определить все типы слов по условиям задачи. Дополнительно можно выводить простым списком слова и все его характеристики, если использовать один цикл для всех заданий, они немного дублируют друг-друга.
 9.186 - дана исходная строка текста, словом является всё то, что не разделено пробелом. В тексте отсутствуют табуляции, но есть перенос на следующую строку. Пробелы в произвольном порядке. Задана ширина поля текста. Вывести текст с учетом ширины поля и с переносом строго по словам, либо если слово не влезает в поле, то переносить по символовам. Реализовать четыре режима выравнивания текста, "слева", "справа", "по центру" и "по ширине". Пробелы для выравнивания добавлять равномерно между словами. Если пробелы не равны, то сделать красиво. Учесть абзацы и перенос строки, по желанию первое слово абзаца делать с отступом.
9.184-9.185 - немного модифицируем и усложним задание. Потребуется реализовать простой логический калькулятор для вычисления выражений, заданных ввиде текста. Из чисел/цифр только 0 и 1. Необходима поддержка всех основных операторов: логические "и", "или", "исключающее или" и "не", как и в си: "&", "|", "^" и "!". Поддержка до как минимум 4 вложенных скобок и контроль их упорядоченности и парности. Ошибку со скобками вывести подробно, где и на какой позиции не хватает. Порядок действий по правилам языка Си и математики. Контролем пробелов или посторонних символов пренебречь и просто вывести сообщение об ошибке, пробел только между операндами, скобки и цифры сплошным. "1 | 0 & ((1 ^ 0 & 1) | (1 & 1)) = результат".

 Глава 10. Функции и процедуры

 Часть из этих задач мы уже делали, поэтому если что пропускаем и функции тоже уже оформляли, так что больше для повторения материала. Для теории подготовить главу 9 в Прате и частично вопросы.

 Функции

 10.1-10.2 - одно задание на выбор, полностью все варианты; использовать одну универсальную функцию с параметрами, можно частично передавать данные через массив. Желательно подробный вывод автоматизировать через варианты, как и в задачнике. Можно использовать генератор случайных чисел.
 10.3-10.5 - простая, одну на выбор, полностью.
 10.6-10.11 - все кроме 10.8(дополнительно), постараться выделить функции как можно более универсальные для всех задач вместе. И комбинировать их по мере необходимости. Опечатка "AD" на "AC" стороны заменить.
 10.8 - желательно реализовать, т.к. часто встречаются.
 10.12 - обьединить в одну функцию, c рычагом типа вызова; вычислить количество четных и нечетных.
 10.13-10.14 - обьединить в одну, реализовав универсальную функцию с параметром степени.
 10.15-10.16 - вроде уже функция определения простоты числа была у нас реализована, если есть, то применить уже готовую. Если нет, то реализовать заново. Обе задачи полностью.
 10.17 - аналогично, функцию факториала уже делали, просто протестировать на заданном примере с данными конкретными числаим.
 10.18-10.19 - реализовать функцию по вычислению суммы и количества цифр в числе, по параметрам. Похожую уже делали, только оформить. Для дополнительного возврата параметров использовать взятие адрес параметра. int digits_in_num(int num, int start, int len, int* sum); Возврат, количество цифр в числе. Параметры: само число, стартовая цифра, количество цифр от старта и сумма по адресу(указателю). Протестировать, на паре простых чисел.
 10.20 - используя только предыдущую функцию, вычислить счастливые номера до предела разумного предела(до шести), все числа не выводить, только счастливые.
 10.21 - уже делали, пропускаем.
 10.22 - тоже уже вроде было ввиде макроса, но если не было такой функции, то реализовать функцию поиска максимального из двух чисел и для 6-10 чисел использовать массив для проверки.
 10.23 - была в 4-ой главе, но на календарь лучше повторить, поэтому оформить функцию красиво с учетом всех параметров дат(в т.ч. и года до нашей эры). Оформить функции: void next_day_date(int* day, int* month, int* year); void prev_day_date(int* day, int* month, int* year) и int is_leap_year(int year). Протестировать функции в таблице дат: февраль високосного и не високосного года, года 1900, 2000, и например 2020. А также через нашу эру. 1-ый год январь и предыдущий год, 31-ое декабря.
 10.24-10.27 - всё что свзяно с этим, уже точно делали раньше. Просто подготовь к демонстрации на вещании. Сокращения дробей разве что у нас не было вроде в отдельной функции оформлено, так что можно и их. 2-3 варианта для тестирования. 10.26-ую и 10.27-ую обьединить в одну, или одну из них реализовать, если покажется сложновато.
 10.28-10.31 - уже саму функцию делали по подсчету количества символов. Используя её, в трех предложениях(строках), вычислить количество вхождений заданного символа в каждой строке, общее количество и доли(показать в процентах) в каждом предложении и долю от общего количества символов во всех трех строках. Дополнительно используя там же функцию поиска индекса символа, определить, в какой строке заданный символ встретился первее остальных.
 10.32 - уже точно делали, пропускаем, ну или если есть желание дополнительно, то можно использую функцию, которую уже делали на палиндром, потестировать с 2-3 словами.

 Процедуры

 Здесь фактически только одно задание, но оно слишком простое, поэтому немного сделаем его универсальней и поинтересней. Рисование нашими командами и собственный простой интерпретатор.

 10.33-10.37 - дана условная доска размерностью 8*8, 16*16 - или любое другое число, но не слишком большое, чтобы удобно помещалось в ввывод на экран с учетом размера шрифта и отладки. Дана строка, которая состоит из команд позиционирования и рисования курсором условно графических примитивов и параметров в шестнадцатиричной форме. Во всех функциях предусмотреть проверку параметров на допустимость и вывод сообщений об ошибке. При выполнении функций выводить эхо команд ввиде текста и параметров, которые удалось достать по потоку. Символы-команды для рисования:
 "P" - позиционирование "карандаша" и сразу за ним две координаты в шестнадциричной форме. Например "P3A" - установить активные чернила на позицию 3 по горизонтали и 10 по вертикали.
 "D" - просто поставить точку в текущую координату.
 "H" - нарисовать горизонтальную линию до параметра горизонтальной позиции, сразу после буквы. Пример: "H5" - нарисовать горизонтальную линию от текущей координаты до координаты 5. Слева или справо. Вертикальная координату оставить такую-же.
 "V" - аналогично, только это вертикальная линия. Также до координаты.
 "R" - нарисовать прямоугольник, следующие две координаты являются другим углом относительно текущей позиции. Использовать команды горизонтальной и вертикальной рисовки линий или можно простыми циклами по желанию. Пример: "R5E" - от текущей позиции нарисовать прямоугольник, до координат 5, 14.
 Дополнительные команды чуть посложнее(хотя бы попробовать):
 "B" - нарисовать произвольную линию из текущей точки в заданную, используя алгоритм Брезенхэма.
 "T" - изобразить треугольник, параметров после 4, это координаты двух других вершин.
 "C" - нарисовать окружность из текущей позиции (центра) и параметром радиуса.
 Изобразить комбинацию фигур на плоскости, можно ввиде любой фантазии. После исполнения всех команд, заполнить линейный массив из символов по размерности равный всему полю и вывести ровно на экран квадрат X*Y, где все отрисованные точки отобразить ввиде знаков "*", остальные можно "." или оставить пустыми и вывести индексы все по краям в буквенной форме(A..Z), примерно как поля.
 10.38 - небольшая, но мы похожую уже делали в самой первой главе, просто символично оформить в функцию. Можно использовать параметры типа int, char - по вкусу.
 10.39-10.40 - уже делали, и кажется во второй главе. Если есть желание для закрепления материалов реализовать или пропустить.

 Рекурсия

 Для рекурсии общая рекомендация быть внимательней, не выходить на большую глубину вызовов, подбирая параметры заданий и данные, таким образом, чтобы можно было отследить ход выполнения программы и легче отладить. При каждом вызове функции, дополнительно, можно выдать в консоль информацию о вызове и параметрах и даже дополнительно статичный счетчик. Если аналогичные функции уже были реализованы, то можно оставить то же самое название и дополнить "_recur" в названии.

 10.41-10.42 - уже точно делали, но если не делали этого рекурсивно, то реализовать оформить обе функции кратко. Возведение в произвольную степень можно оставить целочисленным по параметрам и результатам. Проверить входные данные на минимальную допустимость и простые правила арифметики(0-ая степень, 0 в степене и т.д.).
 10.43-10.44 - классика, частично уже делали, оформить полностью обе. В 10.44 использовать функцию из 10.43, значение количество цифр можно передавать как через возвращаемое значение, так и через статичную переменную.
 10.45-10.46 - одну на выбор, просто достаточно. Последовательность проверить короткой на 3-5 элементов. Реализовать каждую функцию по отдельности или одну функцию на оба варианта. Можно использовать передачу дополнительного параметра по адресу.
 10.47 - тоже классческая, реализовать, много строк не займет. Два или более параметров можно передать по адресу/указателю.
 10.48-10.49 - объединить в одну, один или оба параметра, максимальный элемент - возвращаемое значение, его индекс или текущий индекс можно передать по адресу и использовать его между вызовами. Как удобней.
 10.50 - тоже классика, параметры более 3 не считать, вывод чуть подробнее, ввиде маленькой таблицы параметров функции Аккермана(m, n), для проверки можно заглянуть в Вики.
 10.51 - кажется задание устное, если что просто озвучим на вещании, посмотреть и максимум прикинуть на бумаге.
 10.52 - дополнить одну из первых функций, параметром "направления" вывода цифр в числе или если удобней, то написать функцию заново. Реализовать функцию только на вывод или с возвратом целочисленного результата по жеалнию. Не применять строки, только арифметику.
 10.53 - аналогичная, пропускаем, т.к. еще и есть ввод с клавиатуры.
 10.54-10.55 - объединить и реализовать одну универсальную функцию перевода числа из любой системы счисления в любую; основание систем счисления от 2 до 16 включительно. Добавить контроль данных и не использовать вспомогательные функции. Рекурсивно. Результаты перевода систем счисления можно представить в таблицу со основаниями из 10-тичной в 2,8,16-ти ричную и обратно для проверки.
 10.56 - не очень сложная и уже делали. По возможности использовать по минимум дополнительных параметров, если не получается, то можно применять и адреса параметров для удобства.
 10.57 - тоже функция была, только теперь её нужно рекурсией реализовать. Не забыть проконтролировать входные данные на допустимость и можно еще учесть условно максимальную длину нашей строки.


 Глава 11. Одномерные массивы


 Прочитать и подготовить краткие ответы на вопросы, по главе 10, Праты. Несколько быстрых вопросов обсудим в самом начале вещания, а остальные уже по ходу движения по практическим заданиям. Размеры массива задавать в виде максимального количества объектов через #define(наш OBJECTS_MAX) и после использовать константный размер по условию задачи, если явно не указано иное. Для тестирования брать минимальное количество элементов, необходимое для проверки алгоритма и выводить можно вместе с индексами, для наглядности. В главе удобней использовать несколько универсальных функций и попрактиковаться с перечислениями. Но это лишь рекомендации, можно менять если порядок или обозначения в функциях. Также будем понемногу дополнять эти функции по мере продвижения по главе и может частично сохраним для последующих глав.

 Инициализация массива и вывод его на экран

 11.1-11.2 - Написать функцию создания элементов константного массива в другой массив, значения типа int, определить максимальный лимит. Установить флаг возможности ввода значений с клавиатуры, вместо использования значений второго массива: int array_create_input(int data[], int init[], int isInput, int limit); массив для создания, массив исходных значений, флаг использования клавиатуры, предел по элементам, на выходе контрольное количество элементов.
 11.3-11.9 - Функция заполнения элементов массива целыми элементами из диапазона с параметрами.
int array_create_sequence(int data[], int first, int last, int param, int flags, int limit); массив данных, первый и последний элемент(индексы сделаны по факту, а имелось ввиду скорее элементы старта), параметр смещения, разности или максимального разброса случайности, флаги типов последовательностей в битах(для повторения):
 0 бит - случайная последовательность, param - максимальный разброс значений, первый и последний элемент не учавствуют;
 1 бит - арифметическая последовательность, параметр ввиде дельты, а первые и последний элемент учавствуют, если элемент не попадает на последний, то выводить по пределу;
 2 бит - геометрическая последовательность, аналогична арифметической;
 3 бит - последовательность Фибоначчи, первый и последний элемент используются, если первый элемент не попадает в числа Фибоначчи, то выходим, если последний, то просто заполняем до предела;
 4 бит - все элементы массива, являются уникальными, предел по количеству элементов должен быть меншье чем последовательность, т.е. разность от первого элемента до последнего.
Вернуть количество элментов последовательности сколько реально удалось заполнить. 
 11.10 - дополнительно, если потребуется тренировка, более легкое; без оформления отдельной функции.
 11.12 - полностью, более интересная, можно использовать вспомогательные функции из прошлых глав.
 11.13-11.14 - пока что сделать одну простую вспомогательную функцию вывода на экран последовательности всех элементов массива void array_print(int data[], int limit) мы её постепенно будем дополнять по мере необходимости.
 
 Обработка элементов массива

 Обьявление проверки элемента массива: int array_check_element(int data[], int offset, int parameter, enum array_check_type type, int limit). На вход: сам массив с данными, смещение относительно начала массива, тип проверки, реализовать на этот раз через перечисление: информация - простой отладочный вывод, без возврата результата; больше или меньше параметра; равен ли элемент параметру; делится ли элемент на параметр на цело; является ли число квадратным корнем целочисленного параметра; определить знак числа; четность или нечетность. Функция возвращает либо да или нет, знак элемента, либо признаки(1 или 0).
 enum array_check_type { chk_info, chk_more, chk_less, chk_equal, chk_div, chk_square_root, chk_sign, chk_parity, chk_end }; - вспомогательное перечисление для проверки элемента или массива в целом. Нумерация идет с 0.
 static const char* array_check_name[] = { "info", "is more than", "is less than", "is equal", "is divided by", "is square root of", "sign", "parity" }; - названия сравнений/условий.

 Обьявление модификации элементаint array_modify_element(int data[], int offset, enum array_action_type type, int parameter, int limit);
 enum array_action_type { act_info,  act_move, act_add_sub, act_multiply, act_divide };
 static const char* array_action_name[] = { "info", "move", "addition/subtraction", "multiply", "divide" };

 Обьявление функции вывода или вычисления параметров массива: int array_information(int data[], int size, enum array_inf_value ret).
 enum array_inf_value { inf_info, inf_addr, inf_mem_size, inf_elements, inf_positiv, inf_negativ, inf_zeros, inf_evens, inf_odds, inf_avarage_a, inf_avarage_g, inf_prim, inf_sum, inf_mult, inf_var_sum };
 const char* array_info_names[] = { "Array information, 32-bit compile with integers other may be incorrect.", "Address of array", "Size in memory, bytes", "Elements in array", "Positive numbers", "Negative numbers", "Zeros numbers", "Even numbers", "Odd numbers", "Avarage ariphmetic", "Avarage geometric", "Primary numbers", "Sum of all elements", "Multiply of all elements", "Variable sum, all elements", "Reverse sum" }; 

 11.15-11.16 - составить более универсальную функцию по проверке элемента массива с учетом параметра.  Пример обьявлений и данных, можно менять по вкусу, смотри вспомогательные объявления выше. Протестировать все варианты на минимальных примерах, можно простым автоматом через цикл. Перечисление удобней сгруппировать так как они приведены выше. 
 11.17-11.18 - по аналогии с предыдущим, также более универсальная функция. На вход: массив с данными; смещение элемента; тип выполняемых преобразований, перечисляемый тип: уменьшить и увеличить на параметр; умножить или разделить на параметр; На возврат можно сбросить результат исполнения функции, 0 если всё в порядке и в остальном код ошибки. Пример объявлений, можно менять по вкусу:
 11.19 - функция вывода характеристик массива сразу всё в одном месте сделаем. Дополнительно реализовать реинтерпретацию данных, т.е. на вход может быть подан в теории любой участок памяти с заданным количеством элементов. Поддерживаемые типы для минимального тестирования int и char. Иначе просто сделать тип integer. Пример объявлений, можно исползьзовать свой:
 Первой строчкой вывести адрес массива(указатель), после общий размер в памяти и количество элементов. После уже просто выводим по строчке дополнительные характеристики массива: количество положительных, отрицательных и нулей; количество четных и нечетных; сумма и произведение всех элементов(вывести знак), среднее арифметическое и геометрическое(можно просто целочисленное), сколько чисел является простыми; знакопеременную сумму(не использовать дополнительный условный оператор); сумму обратных элементов массива(1/An) ввиде дроби по целочисленному и дополнить вещественным. По максимуму использовать предыдущие функции.
 Вернуть данные по параметру дополнительному в type, т.е. если например запрашивается сумма элементов, то вернуть её и т.д., туда же включить(по аналогии с битами) вывод на экран или просто по тихому считаем характеристики и возвращаем их значение.

 11.20-11.35 - четные или нечетные на выбор. Буквально одной строчкой. Используя функцию выше из 11.19 - просто потестировать несколько данных, их можно задать или через генератор один раз на общий массив, либо под каждое задание минимальным массивом составить из констант и просто вывести уже результат на экран, без подробного выхода из функции 11.19.

 Использование условий для изменения элементов массива и вывода их на экран

 Обьявление функции: int array_update_commands(int data[], char commands[], int limit);
    // Функция изменения элементов массива парами команд условие-действие и каждое состоит из двух символов, можно между командами добавить пробел. Команды соотвествуют предыдущим перечислениям: array_chek_type и array_action_type.
    // Для ограничений использовать максимум одну букву для команды и одну цифру для параметра.
    // Пример: char commands[] = "L0A0 V4D2" - первая пара: все отрицательные элементы взять по модулю;
    // вторая пара: все элементы которые делятся на 4, разделить на 2.

 11.36-11.39 - используя функцию проверки элемента массива или без нее, по одному варианту в каждом задании, по необходимости, дополнить функцию проверки.
 11.40-11.45 - четные или нечетные на выбор, здесь уже были повторяющиеся, но для закрепления материала, если что функцию проверки элемента дополнить или можно даже функцию вывода всей характеристики массива.
 11.46-11.51 - все задния, но только один вариант по выбору. Написать одну универсальную функцию, по обработке всего массива по правилам с параметрами, которые заданы в управляющей строке. Как мы делали с рисованием разных фигур тогда. Обозначения команд придумать, ну или придумаем вместе спецификацию для этого.
 11.52-11.53 - одну на выбор, не обязательно, если только потребуется для закрепления, но также использовать более универсальную функцию.
 
 Расчет суммы или количества элементов массива, удовлетворяющих некоторому условию

 Обьявление функции суммы: int array_sum_elements(int data[], int size, int parameter, enum array_action type). 
 На вход: массив, его размер, параметр расчета и перечисляемый тип условия(предикат). На выход: сумма элементов. 

 Функция сканирования элемента: int int array_scan_elements(int data[], int size, int parameter, enum array_action type). Вход: адрес массива, его размер, параметр для обработки и тип проверки элемента. Выход: индекс первого найденного элемента.

 Функция подсчета количества элементов массива удовлетворяющих условию: int array_chk_counter(int data[], int size, int parameter, enum array_check_type type). Вход: адрес массива, разме массива, параметр для проверки и тип проверки. Выход: количество элементов в массиве

 11.54-11.62 - реализовать универсальную функцию суммы, как приведено выше, а сами задания использовать для тестирования, каждое задание отдельно. Четные или нечетные на выбор, все варианты. Значения условий можно брать произвольными, главное чтобы не менялся смысл. Удобней для сравнений использовать числа до десятка. По необходимости доработать функции проверки элемента или генерации/создания массива.
 11.63-11.75 - по аналогии, составить функцию сканирования/подсчета элментов массива, в зависимости от условий задания. Пример оформления выше. Каждую третью по выбору для тестирования.
 11.76-11.78 - одну на выбор, для закрепления, просто по тексту, легкая и кажется уже делали. Можно использовать функции.
 11.79 - пропускаем, т.к. простая, но элементы вещественные.
 11.80-11.97 - комбинируя функции выше(в крайнем случае дополнить их) и ограничиться минимальным количеством вычислений в основной программе, каждую третью задачу на выбор. Дополнить функции вычислений по необходимости.
 11.98-11.99 - одну на выбор, постараться использовать наши функции, но если не получается, то делать как есть.
 11.100-11.102 - объединить в одну и реализовать уже просто в тексте, без использования дополнительных функций, можно после реализации оформить ввиде более универсальных функций. int array_unique_elements(int data[], int size, int unique_data[]) и int array_copies_elements(int data[], int size, int copies_data[]) - заполняют массивы элементами и возвращают счетчик этих элементов.
 11.103-11.106 - все обязательно и полностью, написать заново каждую, не используя дополнительные функции. Отметить комментарием как повышенную сложность, может пригодится около олимпиады. 104-105 - объединить поиск уникальных элементов и все задания постараться уложить в один цикл.
 
 Поиск максимума и минимума

 Задание оставшиеся после обсуждений: Дополнить функцию рекурсивного поиска максимума.

 Функция учета количества элементов массива: int array_chk_counter(int data[], int size, int parameter, enum array_check_type type). На вход: адрес массива, его размер, параметр, тип сравнения. Выход: количество элементов уовлетворяющих условию.

 Функция поиска максимум или минимума в массиве: int array_min_max(int data[], int size, int step, int type, int* idx). На вход: массив данных, размер массива, шаг поиска(может быть и отрицательным), тип поиска, адрес индекса для возврата. На выходе само значение элемента или нуль адрес, если не найдено.

 11.107 - написать универсальную функцию поиска максимального или минимального значения в массиве, с дополнительными параметрами и протестировать её в этом задании кратко. Описание спецификации выше.
 11.108-11.111 - одна на выбор, простая.
 11.112-11.113 - одна на выбор, высчитать разницу.
 11.114 - полностью, оценки можно использовать целочисленные.
 11.115-11.118 - одну на выбор.
 11.119-11.123 - одну на выбор, но можно использовать функции которые уже написаны были и получится уже более одного прохода;
 11.124 - полностью оба варианта;
 11.125-11.127 - одна на выбор, легкая.
 11.128-11.130 - также одна на выбор, для закрепления.
 11.131 - по желанию, дополнительно.
 11.132 - полностью все варианты объединить в условно один, вывод поподробнее.
 11.133 - 11.140 - две на выбор, аналогична предыдущей.
 11.141-11.143 - реализовать полностью без использования наших функций, 

 Изменение исходного массива(удаление, вставка и обмен элементов)

 При удалении элмента массива необходимо сдвигать влево оставшиеся справа элементы и корректировать длину массива, записывать в хвост дополнительно нуль или иное значение не требуется. Вставлять элементы нужно с сохранением всех остальных и сдивгом вправо. При обмене использовать по минмуму дополнительных данных.

 Функция обмена значений элементов массива, заданных индексами. int array_xchg_elements(int data[], int size, int idx_a, int idx_b); На вход: массив данных(адрес), максимальный размер, индекс первого элемента и индекс второго элемента. Проверить на допустимость и равнозначность индексов. На выход: 0 - если всё успешно, иначе -1 ошибка.

 Функция обмена значений элементов на интервалах. int array_xchg_range(int data[], int size, int idx_size_flags[]). Вход: массив данных(адрес), размер массива, массив индексов, размеров и флагов(индекс старта, размер интервала и флаги обработки, например в обратном порядке и т.д.). Выход: измененный массив и общее количество перестановок.

 Обмен элементов, перестановки

 11.144 - все варианты, протестировать функцию обмена двух элементов в массиве. Варианты А и Б объединить и реализовать вместе, остальные как есть.
 11.145 - полностью, протестировать дополнительно к предыдущей, функцию обмена групп элементов массива по заданным размерам, все варианты с выводом. Можно использовать один и тот же массив и не генерировать заново данные для проверки.
 11.146 - пропускаем, аналогичная.
 11.147 - только вариант В, остальные уже сделаны.

 Удаление элементов

 Функция удаления одного элемента массива и уплотнение влево остальных. int array_delete_element(int data[], int size, int index); Вход: массив данных(адрес), размер массива и индекс элемента, который необходимо удалить со сдвигом влево. Выход: изменный массив и 0 в случае успеха.

 Функция удаления всех элементов массива, удовлетворяющих условию. int array_delete_all(int data[], int size, int parameter, enum array_check_type type). Вход: массив данных(адрес), размер, параметр для проверки и тип проверки. Выход: количество удалений, измененый массив. Контроль размеров учесть по максимуму.

 11.149-11.150 - одно задание на выбор, через функцию.
 11.151 - оба варианта, уникальность элементов дополнительно через генерацию последовательности.
 11.152-11.153 - по сути одинковые, так что одну на выбор.
 11.154 - копия 11.151, пропускаем.
 11.155 - всего пара элементов, можно пропустить и сразу перейти дальше, т.к. более универасльны следующие задания, ну или если покажутся сложными, то можно сделать и её для разогрева.
 11.156-11.157 - полностью обе, использовать функцию с правилами.
 11.158* - реализовать функцию полностью, без использования каких-либо дополнительных вызовов, как есть и протестировать разок.
 
 Вставка элементов массива

 Функция вставки одного элемента массива по индексу. int array_insert_element(int data[], int size, int element, int index); Вход: массив данных(адрес), максимальный размер; сам элемент для вствки и его индекс. Выход: измененный массив со сдвигом вправо или ошибка.

 Функция вставки элемента во весь массив удовлетворяющих условию. int array_insert_all(int data[], int size, int element, int parameter, enum array_check_type type). Вход: массив данных(адрес), размер, элемент для вставки, параметр для проверки и тип проверки. Выход: количество фактических вставок, измененый массив. Контроль размеров учесть по максимуму.

 11.159-11.160 - один вариант из одного задания на выбор, только протестировать функцию выше, для одного элемента.
 11.161-11.162 - одну на выбор, одинаковые с поиском.
 11.163 - с вызовом нашей функции поиска максимального.
 11.164 - полностью, используя функцию замены всех элементов.
 11.165-11.166 - дополнительно, всего два элемента, можно пропустить.
 11.167 - полностью, используя функцию.
 11.168* - вставку элемента использовать функцией, остальное реализовать как есть в коде.
 11.169-11.171 - одну на выбор, примерно все одинаковые.
 11.172 - пропускаем, уже было со вставкой максимального/минимального элемента.
 11.173-11.175 - одну на выбор, похожая на предыдущие, но сдвиг элементов осуществить в другом направлении.
 11.176-11.177 - одну на выбор, для закрепления.

 Обработка массива с использованием операторов цикла с уловием

 В этом разделе нет смысла использовать функции, поэтому как есть, непрерывным потоком, кроме трех последних.

 11.180-11.182 - дополнительно, одну на выбор, если требуется разминка;
 11.183 - полностью все варианты, без использования функций;
 11.184-11.187 - четные или нечетные на выбор;
 11.188 - пропускаем, уже через функции делали;
 11.189 - без функций, все арифметические операции, и длину числа задать параметрически;
 11.190-11.191 - уже вроде бы делали, ввиде функции, если да, то формируем цифры и вызываем эту функцию.
 11.192 - делали, пропускаем(или дополнить если нет).
 11.193 - подумать над типами и последовательностью.
 11.194 - разберем чуть позже.
 11.195-11.198 - пропускаем, были в предыдущих частях.
 11.199-11.200 - обе, постараться реализовать алгоритм с наименьшим количеством итераций.
 11.201 - дополнительно, по желанию, аналогично предыдущим.
 11.202-11.205 - пропускаем уже были, простые.
 11.206 - делали давно, но повторим, используя массивы и пару вариантов.
 11.207-11.208 - пропускаем, аналогичные уже были.
 11.210-11.212 - три функции набросать в довесок к тому что уже есть(0 или 1 на выходе):
  int array_is_descending(int data[], int size);
  int array_is_ascending(int data[], int size);
  int array_is_eqaul(int data[], int size);

 Работа с двумя и тремя массивами

 Здесь использовать уже имеющиеся функции и дополнительно еще дополнить:


 int array_add(int data_a[], int data_b[], int data_r[], int size); Сумма двух массивов по элементам. Элементы первого и второго складываются и результат помещается в третий массив. Размер один на все массивы, контроль на стороне вызова. Возвращает общую сумму всех элементов результата.

 int array_sub(int data_a[], int data_b[], int data_r[], int size); Разность, между элементами массива. Аналогично сложению.

 int array_mul(int data_a[], int data_b[], int data_r[], int size); Умножение двух массивов по элементам и размещение результата в последнем 
массиве. Размер один на все массивы, контроль на стороне вызова. Возвращает произведение всех элементов результата.

 int array_div(int data_a[], int data_b[], int data_r[], int size); Деление двух массивов поэлементно, и помещение резульата в третий массив. Размер один на все массивы, контроль на стороне вызова. Возвращает среднее арифметическое всех элементов результата.

 int array_find_if(int data[], int result[], int par, int size, enum array_check_type type); Поиск элементов и сохранение их в массив результата. Тип проверки на перечисление, которое у нас уже было. Возвращает количество элементов, которое было в итоге скопировано.

 int array_copy_data(int src[], int dst[], int size, [enum check_type]); Копирование элементов  данных массива поэлементно, если нету поддержки в функции создания, то можно и новую, дополнить бонусом проверку типов. В целом можно использовать предыдущую.

 int array_compare(int data_a[], data_b[], int size); Сравнение элементов двух массивов по одному параметру длины. Если все элменты массива равны между собой, то возвращаем 0. Если хотя бы один элемент первого массива больше соответственно элемента второго массива, то возвращаем 1. Иначе, -1.

 11.214-11.215 - одну через функцию сложения массивов.
 11.216-11.217 - одну на выбор, оба варианта сразу по тексту и одну с функцией;
 11.218 - расчитать объемы в одну строку, все три размера поместить в один массив;
 11.219-11.220 - через процедуру поиска с универсальным условием, одну на выбор;
 11.221-11.222 - через процедуру вычитания одного массива и другой, делать, если не получится 11.223.
 11.223 - полностью, максимально через функции, если затруднительно, то сделать одну из предыдущих.
 11.224 - пропускаем уже делали.
 11.225-11.230 - аналогичные уже делали, сделать две и по жаланию, если потребуется для закрепления то и остальные.
 11.231-11.233 - одну на выбор с использованием наших функций.
 11.234 - не совсем ясно как именно на плоскости.
 11.235 - проверить функцию создания массива, если отсутствует копирование одного в другой, то создать новую.
 11.236-11.244 - каждую третью, с применением наших функций или без, по желанию, легкие.
 11.245 - полностью, без функций, интепретация как повезет.
 11.246 - всё уже реализовали через функции, так что пропускаем.
 11.247 - функцию сравнения двух массивов одинакого размера, по элементам.
 11.248 - немного усложним, замер производится не двумя исследователями, а несколькими(задать параметром). И уже условно вывести направления по итогу.


 Глава 12. Двумерные массивы


 Общие рекомендации для всей главы

 Для размеров массива использовать либо автоматическое определение две пустые пары скобок "[][]", для языка Си. Либо задавать большим константным размером, а для заданий использовать только минимально необходимый параметр размера, для проверки корректности выполнения. Т.е. лучше брать массивы с разным количество строк и столбцов, но небольшие, например 3х2, 4*5 и т.д.
 Оформление вывода удобней делать через пробелы и размеры цифры/букв в один символ или более, но поля выравнивать для улчшения восприятия. Подумать над заглоловком таблицы.
 Адресную арифметику стараться не использовать без лишней необходимости. Если объявление функции слишком длинное будет для вещаний с масштабированием, то можно переносить параметры функции на следующую строку.

 Функции для всей главы

 Минимальный набор функций именно для двумерных массивов, можно не использовать функции написанные для одномерных массивов из предыдущей главы или вместе с ними, по желанию. Чаще разные типы заданий бывают отдельно. Перечисление в этот раз будет общее для всех заданий и функций, начинается с "MX". Названия для каждого из параметра могут быть произвольными.

static const int matrix_act_mask = 0x1F;            // Константная маска до модификатора. Изменить, если поменяется назначение бит.
static const int matrix_check_mask = 0xF000;       // Маска для модификатора проверки массиива или элемента.

enum matrix_type { mx_nop, mx_init_zero, mx_init_input, mx_init_all, mx_init_column, mx_init_row,
                   mx_cr_val, mx_cr_rnd, mx_cr_ariphmetic, mx_cr_geometry,
                   mx_roll_left, mx_roll_right, mx_roll_up, mx_roll_down,
                   mx_info_status, mx_info_sum, mx_info_multiply, mx_info_avr, mx_info_idxs,
                   mx_prn_default = 0x20, mx_prn_row = 0x40, mx_prn_column = 0x80, mx_prn_flipv = 0x100, mx_prn_fliph = 0x200,
                   mx_chk_equal = 0x1000, mx_chk_more = 0x2000, mx_chk_less = 0x4000, mx_chk_div = 0x8000,
                   mx_mod_col = 0x10000, mx_mod_row = 0x20000, mx_mod_sq = 0x40000, mx_mod_pair = 0x80000,
                   mx_end = 0xF0000
                 };

static char* matrix_type_name[] = { "matrix nope",
                                    "initialization zeros", "initialization input", "initialization from source data",
                                    "initialization only columns from source", "initialization only rows from source",
                                    "create value", "create random", "create ariphmetic", "create geometric",
                                    "roll left", "roll right", "roll up", "roll down"
                                  };

 int matrix_init(int data[OBJECTS_MAX][OBJECTS_MAX], int* init, int columns, int rows, enum matrix_type type). Функция инициализации матрицы тремя способами: простое заполнение нулями; копирование матрицы из дополнительных данных и ввод матрицы с клавиатуры. Вход: матрица; дополнительная матрица(если требуется); количество столбцов в матрице; количество строк в матрице; тип заполнения(нули, ввод с клаиватуры, все данные скопировать, заполнить колонкой, заполнить строкой. Интерпретация  Выход: измененные данные и код ошибки, если необходимо.

 int matrix_print(int data[OBJECTS_MAX][OBJECTS_MAX], int columns, int rows, int parameter, enum matrix_type type). Функция вывода матрицы на экран, пока делать по умолчанию, простой таблицей через пробел. Дорабатывать стоит по мере возможности. Вход: данные и размеры; параметр вывода и тип вывода: обычный полностью, вывод строки заданной параметром; столбца; вывод развернутый горизонтально и вертикально(поменять местами строку и столбец). Типы вывода могут быть объединены. Выход: экран.

 int matrix_create_sequence(int data[OBJECTS_MAX][OBJECTS_MAX], int columns, int rows, int parameter, enum matrix_type type). Функция создания данных массива от инициализорованного изначально(возможно позже изменим). Вход: данные; колонки; строки; параметр; тип последовательности - фиксированное значение по всем элементам, случайные значения по параметру, арифметическая и геометрическая последовательность(считаем от нуля до параметра). Выход: данные обновленные, без учета предыдущих значений(может потом изменим это правило). При генерации случайной последовательности с параметром 0, использовать максимальное целочисленное значение или выйти по вкусу.

 int matrix_roll(int data[OBJECTS_MAX][OBJECTS_MAX], int columns, int rows, int counter, enum matrix_type type). Функция циклического сдвига матрицы полностью по заданному направлению и с учетом счетчика. Вход: данные; колонки; строки; счетчик сдвига и тип сдвига. Выход: данные.
  
 Простейшие задачи

 12.1-12.21 - каждую третью на выбор, оформить всё в одну задачу и единственный массив, для трениорвки. Вывод в консоль подробный, что именно делается и по каким параметрам.

 Заполнение и вывод массива нестандартными методами

 12.22 - уже делали, если только для разогрева и на повторение.
 12.23-12.25 - смысл один и тот же, но просто реализиовать функции инициализации матрицы, формирование последовательностей и вывода всех возможных вариантов, будем добавлять правила еще достаточно много.
 12.26-12.27 - вывести на печать матрицы сформированные копированием строки или столбца и проверить циклические сдвиги во все стороны.
 12.28-12.30 - реализовать как одно, с произвольными размерами по горизонтали, вертикали(в т.ч. квадрат). Изначально массив состоит из нулей, а стртовое значение 1. Сохранить во время движения путь в виде пар чисел [east, 5]. Когда уже алгоритм дошел до конца, осуществить чтение элементов в последовательность, в обратном порядке спирали используя путь сохранения, менять элементы нельзя. Сначала реализовать чтобы работало даже в простом случае, размеров 1х1. После стараться сделать решение компактным. Примеры данных(можно свои):
    const int directions = 4;
    int data_dir[4][2] = { {0, -1}, {+1, 0}, {0, +1}, {-1, 0} };
    int next_column = 0, next_row = 0, move_dir = 1, element = 1, trail_size = 0, move_size = 0;
    int data_trail[OBJECTS_MAX][2];     // Запомним путь движения спирали.
    char* dir_name[] = { "north", "east", "south", "west" };

 12.31 - решить задание отдельно, не используя вспомогательные функции по ходу основного решения программы(может после перенесем в функцию).
 12.32-12.34 - не использовать условия, а просто протестировать функцию нашего вывода матрицы с типом вывода и параметром, например вывод столбцов со второго по четвертый и т.д.
 
 Расчетные задачи

 int matrix_info(int data[OBJECTS_MAX][OBJECTS_MAX], int columns, int rows, enum matrix_type type); Функция анализа и вывода информации о матрице. Вход: данные; колонки; строки; тип возвращаемого значения и флаг вывода через mx_prn_default если бит установлен; вспомогательный параметр. Выход: если включен бит печати, то вывести всю информацию на экран и вернуть одно значение, которое запрашивается. Комментарий: для анализа бита использовать битовую комнаду (type & mx_prn_default).

 int matrix_check_element(int data[OBJECTS_MAX][OBJECTS_MAX], int column, int row, int parameter, enum matrix_type check); Функция проверки одного элмента матрица на заданное условие с параметром. Вход: данные; индексы столбца и строки; тип проверки; параметр проверки. Выход: истина или ложь в зависимости от результата проверки. Допустимость индексов сопоставить только с OBJECTS_MAX, чтобы не было выход за пределы по памяти.

 int matrix_check_info(int data[OBJECTS_MAX][OBJECTS_MAX], int columns, int rows, int* par_cnt, enum matrix_type act_chk) Функция получения информации о всей матрице или её отдельного элемента, строки или столбца с учетом условия. Вход: данные; столбец и строка; тип проверки с учетом флага модификатора; параметр и возврат через него же счетчика результата. Выход: результат с учетом проверки или код ошибки. Комментарий: если флаг модификации столбца установлен, то параметр column использутся как конкретный столбец и все строки в нем; аналогично для параметра строки; если используются оба, то проанализировать только элемент.

 В заданиях, где имеется анализ элементов условно с флагами (0 или 1) и т.д. можно использовать функцию инициализации массива с настройкой "случайный элемент" и параметром 2.

 12.35-12.46 - все задания примерно одинаковые, использовать функцию выше для возврата суммы столбца или строки с применением модификатора, по номеру искомой информации. Каждую третью на выбор, с различным представлением данных.
 12.47 - протестировать через функцию.
 12.48-12.51 - каждую вторую на выбор, все варианты, сумму квадратов и среднее арифметическое внести в тип матрицы функции см. выше.
 12.52-12.55 - аналогичны предыдущим, одну на выбор для закрепления или две, если не совсем понятно.
 12.56 - протестировать просто функцию об информации матрицы с выводом на экран и при необходимости, дополнить. Все варианты сразу.
 12.57-12.59 - одну на выбор, просто через вызов функции.
 12.60-12.61 - одну на выбор, тоже через функцию с параметром.
 12.62 - по идее уже всё протестировано должно быть, так что пропускаем.
 12.63-12.65 - одну на выбор, но реализовать дополнением функции matrix_info и с тестированием по выводу на экран.
 12.66-12.69 - четные или нечетные на выбор, все варианты с использованием функции с модификаторами проверки.
 12.70 - дополнительно по желанию, в целом интересное задание с выводом текстового результата.
 12.71-12.72 - одну на выбор, тоже все варианты, для тестирования функии.
 12.73 - требуется нахождение максимального и минимального элемента, почему-то задача попала не в тот раздел, пока временно пропустим или перенесем ниже.
 12.74-12.75 - обе реализовать как есть без использования функций, условно задания повышенной сложности.
 12.76-12.77 - четные или нечетные на выбор, аналогичны предыдущим, вывод подробнее и без одномерного массива совсем, просто функция.
 12.78-12.79 - обе, удобно объединить в одну, дополнить анализ матрицы на пары элементов, аккуратно не выходя за пределы, как с учетом ряда, так и столбца.
 12.80 - реализовать без функций, условно повышенная сложность, посчитать итерации на каждое сравнение, они известны, но выведем.
  
 Нахождение максимума и минимума

 Здесь очень много однотипных заданий, так что дополняем наши функции и проверяем типовые условия с параметрами, выводим результат подробнее. Дополняем функцию matrix_info и наше перечисление параметрами mx_info_min, mx_info_max, mx_mod_last = 0x80000 (первый макс-мин или последний находим). Остальные модификаторы учитываются также. Если не было изменено, то заменяем входные данные с "int columns" на "int* columns" и "int rows" на "int* rows". Максимальный или минимальный элемент на выход в результат, как обычно.

 12.81-12.84 - одну на выбор, через тестирование функции.
 12.85-12.88 - тоже все одинаковые, одну на выбор.
 12.89 - более общая из следующих, так что лучше её полностью, внимательно по направлениям и порядку расположения элементов, все варианты. Дополнительные массивы не применять.
 12.90-12.91 - по желанию, дополнительно, аналогичны предыдущей.
 12.92-12.93 - одну на выбор, без использования функции для одномерного массива и с использованием функции для матрицы, просто через цикл.
 12.94-12.99 - все похожие, каждую третью на выбор, только вывод подробнее и если разница только в модификаторе порядка, то можно в один цикл обе задачи.
 12.100-12.101 - объединить в одну, и нарисовать красивую таблицу, где будут и очки команд и текстовые пояснение, использовать табуляции и реальные данные(а то давно мы что-то не оформляли ничего).
 12.102-12.110 - четыре(две) на выбор, но выбрать так, чтобы попались комбинации минимума, максимум и/или строка столбец. Если индексы столбца или строки находятся в одном цикле вместе, то только два задания.

 Проверка условия после выполнения расчетов

 С одной стороны почти все задания уже делали или очень похожие, с другой для универсальной проверки вводить новые правила через строку управления смысла нету. Так что выборочно и с дополнениями, которые могут возникнуть по ходу доработки функций. 

 12.111-12.114 - все аналогичные, одну на выбор, так что можно в пару строк с вызовом.
 12.115-12.116 - одну на выбор, но в этот раз применить для хранения одного бита информации массив из unsigned char, где каждый бит отвечает за занятость кресла или вагона(ограничить размер в 8 бит), по количеству строк обычный одномерный массив, реализовать без функций, кроме печати и вывести сколько бит всего, занятых и свободных.
 12.117-12.120 - одну на выбор, оба варианта.
 12.121-12.123 - одну на выбор, через сравнение.
 12.124-12.125 - одну на выбор, просто внимательно с индексками.
 12.126 - сначала вызвать функцию и найти среднюю, а потом дополнить до ближайшего по смещению там же.
 12.127-12.129 - уже были, можно решить дополнительно, используя наши предыдущие функции.
 12.130 - полностью, без функий, команды удобней отображать по буквам, но как удобней, все варианты, дополнительные данные по необходимости. Постараться максимальное количество вычислений расположить в главном цикле.
 12.131 - реализовать проверку матрицы на магический квадрат и дополнительно тут же - создание подобного квадрата, возможно после вынесем в функции и в библиотеку.
 12.132-12.134 - все объединить в одну, постараться сделать покомпактнее, но с выводом, при итерациях алгоритма. int matrix_elements_copies(int data[OBJECTS_MAX][OBJECTS_MAX], int columns,  int rows, int counter). Функция определения наличия строго n-копий хотя бы одного элемента в массиве. Возвращает количество элементов, счетчик копий которых заданы в параметре.

 Обработка массива с использованием операторов цикла с условием

 Стараться объединять задания по группам и использовать массивы для обозначения. Там где в заданиях есть "последняя цифра", можно заменить на "делится".
 
 Функция линейного поиска, поиска элемента с дополнительным параметром проверки. int matrix_find_element(data[OBJECTS_MAX][OBJECTS_MAX], int* columns, int* rows, int par, enum matrix_type chk); Параметры аналогичны предыдущим функциям.

 Функция определения, является ли матрица, строка или столбец - последовательностью упорядоченныъх элементов по возрастанию, убыванию или все элементы равны между собой. Использовать настройки asc, mx_chk_dsc для последовательностей и предыдущии. int matrix_is_sequence(int data[OBJECTS_MAX][OBJECTS_MAX], int columns, int rows, int parameter, enum matrix_type check). Параметры аналогичны предыдущим функциям.

 12.135-12.138 - четные или нечетные на выбор, протестировать функцию поиска без дополнительных условий проверки, учитывая только флаги порядка следования.
 12.139-12.140 - одну на выбор все варианты с учетом параметра, если по условию "заканчивается цифрой", то можно заменить на "делится на цифру".
 12.141 - полностью с дополнительным вариантом проверки на ровную последовательность, т.е. каждый следующий элемент в столбце или строке равен предыдущему с использованием функции по описанию выше.
 12.142-12.145 - четные или нечетные на выбор, все варианты, использовать нашу функцию, желательно объединить в одну и через таблицы оформить в виде одного цикла. Например: tasks_find_all = N; char* tasks_name[] - названия и условия заданий; int tasks_find_mods[] = { mx_chk_div, 7, ...} - параметры всех вызовов функций.
 12.146-12.149 - четные или нечетные, желательно объединить по параметрам вместе с предыдущими двумя и реализовать через таблицы.
 12.150-12.153 - четные или нечетные на выбор, все варинаты. Применить наши предудущие функции и оформить подробнее вывод. Для удобства можно уплотнить все варианты в одном цикле и использовать настройки также в массивах.

 Работка с квадратными массивами

 Очень много однотипных и очень простых заданий, оставим только те что посложнее. Можно, конечно, ввести главную и побочную даигональ матрицы как дополнительные модификаторы по аналогии со столбцами и строками, но алгоритмы от этого сильно не изменятся. Ну или посмотрим дополнительно.

 12.154-12.187 - все очень простые, так что пропускаем, единственно что можно дополнить параметр вывода для mx_prn_diags - выводим только диагонали при печати матрицы, если только это влезает и не потребуется двигать наш перечисляемый тип.

 12.188-12.191 - условно повышенной сложности, без дополнительных функций кроеме вывода, постараться упаковать код по вариантам всё сразу. Прямо по ходу программы.

 Изменение исходного массива

 Функция изменения матрицы по общим правилам и параметрам заданные в массиве параметров. Условия проверки условий элементов, дополнительно по элементам . Там где есть деление, то заменить его на целочисленное умножение. Дополнительные параметры для перечисляемого типа, держим в уме что для каждого типа действия могут как для всей матрицы, строки, столбца или даже отдельного элемента.
 - mx_upd_val, заменить элементами матрицы значениями, которые содержаться после параметров в массиве values, если комбинации модов 
 - mx_upd_move, переместить элементы матрицы по индексам столбца или/и строки, элементы назначения переписываются элементами источника;
 - mx_upd_xchg, обменять элементы матрицы по индексам;
 - mx_upd_add, прибавить(вычесть) значения к элментам матрицы значения;
 - mx_upd_mul, умножить элементы матрицы на значения;
 - mx_upd_roll, сдвиг матрицы по направлениям и смещеням.

 Функция: int matrix_update(int data[OBJECTS_MAX][OBJECTS_MAX], int columns, int rows, int values[], enum matrix_type type). Параметры аналогичны предыдущим функциям, но вместо параметра - массив параметров. Нулевое значение всегда отвечает за условие дополнительной проверки, далее следуют параметры строки и/или столбца и после уже значения(если требуются) для заполнения или действия.
 Пример массива values: [0] = 2 - если проверка на четность, [1] = 1 - первая строка матрицы, [2] = 3, третья строка матрицы. Если действие равно "переместить" элементы, то выполнить: переместить все четные элементы строки 3 в строку 1, остальные элементы оставить без изменений. По аналогии можно использовать координаты и строки и столбца или без них, тогда для всей матрицы. Индексы идут в порядке очереди и пропускаются, даже если их нет в действиях.

 12.192-12.193 - одну на выбор.
 12.194-12.196 - одну выбор, все варианты.
 12.197 - все варианты с предварительным формированием последовательности,  можно использовать функцию из предыдущей главы с одномерными массивами.
 12.198-12.199 - одну на выбор, с выводом в консоль.
 12.200 - краткая, в одну строчку.
 12.201-12.204 - одну на выбор, все примерно одинаковые.
 12.205 - оба варианта, без дополнительных массивов.
 12.206-12.207 - все варианты, если есть "оканчивающийся цифрой", то можно заменить на "делится нацело".
 12.208-12.210 - одну на выбор, два вирианта.
 12.211-12.212 - любая, проконтролировать выход из функции и проверить результат.
 12.213-12.216 - частично уже решали, выбрать одну, более разнообразнее.
 12.217 - пропускаем, была в предыдущем разделе.
 12.218-12.227 - четные или нечетные на выбор, объединить все задания как делали с параметрами в массив, т.е. правила в массив и после уже через один цикл с выводом результата.
 12.228-12.229 - используется клавиатура, но суть не меняется, так что пропускаем.
 12.230-12.233 - четные или нечетные, использовать смещение.
 12.234-12.239 - каждую третью, с подробным выводом, скорректировать размерности массива при выводе.
 12.240 - дополнительно, если требуется для закрепления.
 12.241-12.249 - каждая третья, все варианты, там где есть ввод с клавиатуры, то заменить на переменные.
 12.250-12.253 - четные или нечетные на выбор, оформить красиво в консоль.
 12.254-12.257 - дополнительно, если требуется закрепление материала.
  

 Работа с несколькими массивами


 Посмотреть на паралельные.


 Двумерные символьные массивы

 Кроме повышенной сложности еще и отрисовать изображения. Не забыть про логический триггер. С использованием И-НЕ или иных элементов.
