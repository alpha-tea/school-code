;Welcome to 8-Bit Tea Party!
;
;Assembler, Intel 8086/8088, IBM PC.
;
;Grabbag (Duke Nukem Theme).
;Composed by Lee Jackson.

;Процессор Intel 8086\8088, 5 Мгц.
;Разрядность АЛУ: 16 бит.
;Шина данных: 16 бит.
;Шина адреса: 20 бит, 1 Мбайт.
;Рельный режим адресации, DOS 5.0.
;Основная память: 640 Кбайт.
;Системная память: 384 Кбайт.

;Основные регистры процессора 8086.
;AX[ah,al] основной аккумулятор;
;BX[bh,bl] база, смещение данных;
;CX[ch,cl] счётчик для комманд;
;DX[dh,dl] данные, порты ввода-вывода,"часть аккумулятора".
;SI        индекс источника, 16 бит.
;DI        индекс приёмника, 16 бит.
;BP        база, смещение стека.
;SP        указатель вершины стека.
;CS:IP     адрес сегмента кода.
;DS:[offs] сегмент данных.
;ES:[offs] сегмент данных, дополнительно.
;SS:SP     сегмент стека, с вершиной.
;IP        указатель на текущую комманду.

;Регистр флагов, 16 бит, флаги:
;CF        флаг переноса;
;ZF        флаг нуля.
;OF        флаг переполнения.
;SF        флаг знака.
;AF        вспомогательное переполнение.
;PF        признак чётности.
;Младшая часть регистра флага AF.

;Регистр   сегмент   замена
;  IP        CS        -
;  SP        SS        -
;BP+SI[DI]   SS     CS,DS,ES
;  BX        DS     CS,SS,ES
;SI,DI[base] DS     CS,SS,ES
;SI -> DI   DS,ES      -
;Модели памяти:
;tiny
;small
;compact
;medium
;large
;flat



CPU 8086        ;только команды процессора 8086.

;Глобальные константы.

SCR_BUFFER      equ 0xB800

        ;Начало программы.
        org 0x100
        push ax
        push bx
        push cx
        push dx

;Вещание №5. Инструкции арифметики и флаги.
      ;Вычитание:
        mov ax,0x0000
        mov bx,0x0000
        mov al,0x28
        mov ah,0x31
;sub dst,src - вычитание.
        sub ah,al       ;reg:reg, 3 clk;
        sub ah,[byte_b] ;reg:mem, 16 clk+EA;
        sub al,0x22     ;acc(reg):imm, 4 clk;
        sub [byte_b],al
        mov al,[byte_b]
        sub byte [byte_b],0x01 ;mem:imm, 17 clk+EA;
        mov al,[byte_b]
;sbb dst,src - вычитание с заёмом флага CF.
        mov ax,0x1001
        mov bx,0x0503
        sub al,bl
        sbb ah,bh       ;Ожидаем результат 0AFE(-2);
;dec dst - декремент приёмника на 1.
        dec al       ;reg8  3 clk, 2 bytes;
        dec ax       ;reg16 2 clk, 1 bytes;
        mov al,[byte_a]
        dec byte [byte_a]       ;15 clk+EA
        mov al,[byte_a]
;neg dst - формирует отрицательное число.
        mov al,0x01
        neg al     ;2 clk
        mov ah,[byte_b]
        neg byte [byte_b]       ;16 clk+EA
        mov ah,[byte_b]
        mov al,0x00
        neg al     ;CF=0;
;cmp dst,src - сравнение.
        mov ax,0x0102
        cmp al,ah               ;reg:reg, 3 clk;
        cmp ax,0x0001           ;reg:imm, 4 clk;
        cmp byte [byte_a],0x01       ;mem:imm, 10 clk+EA;
        cmp al,[byte_a]         ;reg:mem. 9 clk+EA;
;aas,das - выравнивание для вычитания и обратно.
      ;Умножение:
;mul src - умножение без знака.
;imul src - умножение со знаком.
        mov al,0x02
        mov bl,0x03
        mul bl     ;70-77 clk, 2 bytes;
        mov bx,0x1000
        mul bx     ;118-133 clk
        mov al,0x01
        mul byte [byte_b]       ;76-83+EA
        mov ax,0x1000
        mul word [word_a];124-139+EA
        mov al,-0x05
        mov bl,0x02
        imul bl
      ;Деление:
;div src - целочисленное деление без знака.
;idiv src - целочисленное деление со знаком.
        mov ax,0x0100
        mov bl,0x10
        div bl     ;al - результат, ah - остаток. 80-90 clk.
        div byte [byte_b]
        mov dx,0x0001
        mov bx,0xAAAA
        div bx       ;144-162 clk
        mov dx,0x0001
        div word [word_d]
        ;idiv аналогичен imul.
        ;mov bl,0x01    ;коварный ход от Данилы в комментариях)))
        mov bx,0x0001   ;следим за размерностью операндов.
        mov ax,0x0200
        mov dx,0x0000
        ;div bl         ;операнд назначения должен вмещать частное от деления.
        div bx
;cbw al, cwd ax - конвертирует байт в слово или слово в двойное слово.
        mov al,-0x05
        cbw         ; 2 clk; оптимизация
        cwd         ; 5 clk;
;Логические операции:
;not dst - отрицание, логическое НЕ.
        mov al,0x0F
        not al          ;3 clk
        mov ah,[byte_a]
        not byte [byte_a] ;16 clk+EA
        mov ah,[byte_a]
;and dst,src - логическое И.
        mov al,0xAA
        mov ah,0x0F
        and al,ah       ;reg:reg, 3 clk
        and al,0x03     ;acc:imm, 4 clk
        and [byte_a],ah ;mem:reg, 16 clk+EA
        mov bh,[byte_a]
        and byte [byte_a],0xFF ;mem:imm, 17 clk+EA
        mov bh,[byte_a]
;or dst,src - логическое ИЛИ.
        mov dl,0xAA
        mov dh,0x0F
        or  dl,dh       ;reg:reg, 3 clk
        or  al,0x03     ;acc:imm, 4 clk
        or  [byte_a],dh ;mem:reg, 16 clk+EA
        mov bh,[byte_a]
        or  byte [byte_a],0xFF ;mem:imm, 17 clk+EA
        mov bh,[byte_a]
;xor dst,src - логическое ИСК.ИЛИ.
        mov dl,0xAA
        mov dh,0x0F
        xor dl,dh       ;reg:reg, 3 clk
        xor al,0x03     ;acc:imm, 4 clk
        xor [byte_a],dh ;mem:reg, 16 clk+EA
        mov bh,[byte_a]
        xor byte [byte_a],0xFF ;mem:imm, 17 clk+EA
        mov bh,[byte_a]
;test dst,src - логическое И без сохранения результата.
        mov dl,0xAA
        mov dh,0x0F
        test dl,dh       ;reg:reg, 3 clk
        test al,0x03     ;acc:imm, 4 clk
        test [byte_a],dh ;mem:reg, 9 clk+EA
        mov bh,[byte_a]
        test byte [byte_a],0xFF ;mem:imm, 11 clk+EA
        mov bh,[byte_a]
;Битовые сдвиги.
;sal, shl: dst,counter - сдвиг влево
        mov cl,0x04    ;кол-во сдвигов.
        mov ax,0x0101
        sal ah,1       ;2 clk
        shl al,1
        sal al,cl    ;8 clk + 4 на бит
        shl byte [byte_a],cl ;20 clk+EA+4 на бит
        mov al,[byte_a]
        sal byte [byte_b],1    ;15 clk+EA
        mov al,[byte_b]
;sar, shr: dst,counter - сдвиг вправо
        mov cl,0x04    ;кол-во сдвигов.
        mov ah,-0x05
        mov al,0x80
        shr al,cl    ;8 clk + 4 на бит
        sar ah,cl
        sar byte [byte_a],cl ;20 clk+EA+4 на бит
        mov al,[byte_a]
;Ротация битов.
;rol\ror dst,counter - ротация влево,вправо.
;rcl\rcr dst,counter - ротация бит вдево,вправо с флагом переноса.
        mov cl,0x04    ;кол-во сдвигов.
        mov ah,0x01
        mov al,0x80
        rol al,cl    ;8 clk + 4 на бит
        rol ah,1
        ror ah,1
        ror al,cl
        ror byte [byte_a],cl ;20 clk+EA+4 на бит
        mov al,[byte_a]
        mov ah,0x07
        mov al,0xE0
        mov cl,0x02
        rcr ah,cl
        rcl al,cl
        rcr al,cl
        rcl ah,cl
        rcl byte [byte_a],cl
        mov al,[byte_a]
;Вещание №4. Инструкции арифметики и флаги.

      ;Сложение:
        mov dl,0x34
        mov dh,0x12
        add dl,dh  ;reg:reg, 3 clk;
        add dl,byte [byte_a] ;reg:mem, 9 clk+EA;
        add dl,0x03     ;reg:imm, 4 clk;
        mov al,[byte_a]
        add [byte_a],dl ;mem:reg, 9 clk+EA;
        mov al,byte [byte_a]
        mov ah,0x00    ;add 16 bit, using 8 bit operands;
        mov al,0x81
        mov bl,0xA9
        mov bh,0x0A
        add al,bl      ;флаг переноса включен
        adc ah,bh      ;используем флаг переноса
        pushf
        mov ah,0x00
        sahf       ;обнулим флаги.
        mov al,-0x50
        mov ah,-0x40
        add ah,al  ;флаг переполнения влючен и установлен флаг знака
        popf
        mov al,[byte_a]
        inc al         ;увеличение на 1, 3 такта.
        inc dx         ;2 такта
        inc byte [byte_a]   ;15+ЕА тактов
        add ax,word [byte_a]
        mov al,[byte_a]
;BCD - двоично-десятичный код, в каждом полубайте хранится цифра от 0 до 9.
;пример: 74 = 0111 0100 - двоичный вид(битовое представление)
        mov al,0x30
        aaa        ;из упакованного в десятичное число
        add al,0x05
        daa        ;из двоичного в упакованное.
        jmp return

;Вещание №3.
;Архитектура 8086, типы адресации и инструкции перемещения данных.
;Комманды общего назначения.
        mov al,0x01  ;immed, 4 clk
        mov ah,al    ;reg:reg, 2 clk
        mov ax,[word_c] ;10 clk
        mov dl,[byte_a] ;8 clk+EA
        mov [word_c],word 0xABCD ;10 clk+EA
        mov bx,[addr_segm]
        mov es,bx
        mov es,[addr_segm]  ;8 clk+EA
        push cs             ;11 clk
        push word [addr_segm];17 clk
        pushf
        lahf    ;load flag to ah
        sahf    ;store ah to flag
        popf
        pop bx
        pop ax
        xchg ax,bx   ;acc-reg, 3 clk
        xchg dx,[word_b]; reg-mem, 17 clk+EA
        xchg bx,dx      ;reg-reg, 4 clk
        mov al,0x03
        lea bx,bytes_t
        xlat
;Вычисление эффективного адреса объекта.
        lea si,[bytes_t]    ;2 clk+EA
        mov al,[si+3]
        les di,ds:[words_t]
        mov [addr_offs],si
        mov ax,ds
        mov [addr_segm],ax
        lds bx,ds:[addr_offs]
        mov al,[bx]
;
        jmp return
byte_a      db 0x01
byte_b      db 0x02
word_d      dw 0x0104
word_b      dw 0x1A2B
word_c      dw 0x3C4D
addr_offs   dw 0x0505
addr_segm   dw 0x6060
bytes_t     db 0x01, 0x02, 0x03, 0x04
words_t     dw 0x1A1B, 0x2C2D, 0x3E4F

;Вещание №2.
;Архитектура 8086, типы адрессации и инструкции перемещения данных.
;Методы и типы аресации данных.

        mov dx,0x0101;Непосредственная адресация.
        mov ax,dx    ;Регистровая адресация, 2 такта.
        mov bx,ds:[bytes_table]     ;Прамая адресация из памяти, 8 тактов.
        mov ax,ds:0x0100
        mov bx,bytes_table
        mov dh,[bx]       ;ds сегмент по умолчанию.
        mov dl,ds:[bx+2]  ;база + смещение
        mov di,0x003
lab_1:  mov cl,es:[di]
        mov bp,words_table
        mov ax,cs:[bp+di] ;Изменение сегмента + 2 такта, база + индекс.
        ;База + индекс + смещение, ооочень долго по тактам.
        mov ax,ds:[bp+di+1] ;Для базы только регистры: BX, BP, SI, DI.
;Переходим к общим инструкция перемещения данных
        jmp return

bytes_table     db 0x01, 0x02, 0x03, 0x04
words_table     dw 0x1A1B, 0x2C2D, 0x3E4F


;Вещание №1. Архитектура 8086 и программа "Привет Мир!", с БИОСом и буфером.
        ;Установим курсор в позицию.
        mov ah,02h
        mov bh,0x00
        mov dx,0x0A08
        int 10h

        ;Печатаем отдельный символ.
        mov cx,0x05
        mov ah,0x0A
        mov al,0x43
        xor bh,bh
        int 10h

        ;Печатаем строку с БИОСом
        mov ax,0x1300
        xor bh,bh
        mov bl,00011111b
        mov cx,0x000C
        mov bp,string
        int 10h

        ;Вывод строки в буффер экрана.
        mov ax,SCR_BUFFER
        mov es,ax
        mov di,0x0100
        mov si,string
        mov bh,00101111b
Prt_1:  mov bl,ds:[si]
        or bl,bl
        jz Prt_2
        mov es:[di],bx
        inc si
        add di,0x02
        jmp Prt_1
Prt_2:  mov ah,0x09
        mov dx,string
        push cs
        pop ds
        int 21h
return:

        pop dx
        pop cx
        pop bx
        pop ax
        ret


string  db 'Hello World!&', 0
word_a  dw 0x1111
dword_b dd 0x11111111
reserv  db 32 dup (0)

